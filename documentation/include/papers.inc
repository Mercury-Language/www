<!--
WHEN UPDATING THIS FILE, REMEMBER TO UPDATE THE TABLE OF CONTENTS!
-->
<h2>Documentation<span class="submenutitle">/ papers and presentations </span></h2>
<p>
The Mercury team have written quite a few papers about the Mercury
programming language, its implementation techniques, design, theoretical
basis and other topics. In addition, we have written several papers
on <a href="papers.html#related">related</a> topics.
Almost all are available here as PostScript
files, compressed using gzip, or as PDF.
</p>
<p>
Below the papers, the notes from a number of
<a href="papers.html#presentations">presentations</a>
given on Mercury, at a variety of levels, are also available.
</p>
<h2>Contents</h2>
<h3><a href="papers.html#mercury">Papers on Mercury</a></h3>

<ul class="nonindentlist">

<li>
<strong>
<a href="papers.html#pbone_phd_thesis">
Automatic parallelisation for Mercury.
</a>
</strong>
<br>
Paul Bone
<br>
<em>
Ph.D. Thesis
</em>
Department of Computing and Information Systems,
The University of Melbourne.
December 2012.
<p>
</li>

<li>
<strong>
<a href="papers.html#loop_control">
Controlling loops in parallel Mercury code.
</a>
</strong>
<br>
Paul Bone, Zoltan Somogyi and Peter Schachte
<br>
<em>
Declarative Aspects and Applications of Multicore Programming
</em>
Philadelphia, Pennsylvania, USA, January 2012.
<p>
</li>

<li>
<strong>
<a href="papers.html#threadscope">
Profiling parallel Mercury programs with ThreadScope.
</a>
</strong>
<br>
Paul Bone and Zoltan Somogyi
<br>
<em>
21st Workshop on Logic-based methods in Programming Environments.
</em>
Lexington, Kentucky, July 2011.
<p>
</li>

<li>
<strong>
<a href="papers.html#overlap">
Estimating the overlap between dependent computations
for automatic parallelization.
</a>
</strong>
<br>
Paul Bone, Zoltan Somogyi and Peter Schachte.
<br>
<em>
Theory and Practice of Logic Programming, 27th Int'l. Conference on Logic
Programming (ICLP'11) Special Issue, volume 11, issue 4-5.
</em>
Lexington, Kentucky, July 2011.
<p>
</li>

<li>
<strong>
<a href="papers.html#dep_and_parallel">
Minimizing the overheads of dependent AND-parallelism.
</a>
</strong>
<br>
Peter Wang and Zoltan Somogyi.
<br>
<em>
Technical Communications of the 27th International Conference on Logic
Programming (ICLP'11), LIPICS Vol. 11.
</em>
Lexington, Kentucky, July 2011.
<p>
</li>

<li>
<strong>
<a href="papers.html#bmellor-hons">
Towards software transactional memory for real-world programs.
</a>
</strong>
<br/>
Ben Mellor.
<br/>
<em>
Honours report,
</em>
Department of Computer Science and Software Engineering,
The University of Melbourne,
October 2009.
<p>
</li>

<li>
<strong>
<a href="papers.html#quan-phd">
Region-based memory management for the logic programming language Mercury.
</a>
</strong>
<br>
Quan Phan.
<br>
<em>
Ph.D. thesis.
</em>
Department of Computer Science,
Catholic University of Leuven (KUL),
November 2009.
<p>
</li>

<li>
<strong>
<a href="papers.html#more-precise-rbmm">
More precise region-based memory management for Mercury programs.
</a>
</strong>
<br>
Quan Phan and Gerda Janssens.
<br>
<em>
Proceedings of the Ninth International Colloquium on
Implementation of Constraint and Logic Programming Systems (CICLOPS '09),
</em>
Pasadena, California, July 2009.
<p>
</li>

<li>
<strong>
<a href="papers.html#path-sensitive-ppdp">
Path-sensitive region analysis for Mercury programs.
</a>
</strong>
<br>
Quan Phan and Gerda Janssens.
<br>
<em>
Proceedings of 11th International Symposium on
Principles and Practice of Declarative Programming,
</em>
Coimbra, Portugal, September 2009.
<p>
</li>

<li>
<strong>
<a href="papers.html#runtime-support-ismm08">
Runtime support for region-based memory management in Mercury.
</a>
</strong>
<br>
Quan Phan, Zoltan Somogyi and Gerda Janssens.
<br>
<em>
Proceedings of the 2008 International Symposium on Memory Management (ISMM '08),
</em>
Tucson, Arizona, June 2008.
<p>
</li>

<li>
<strong>
<a href="papers.html#static-region-analysis">
Static region analysis for Mercury.
</a>
</strong>
<br>
Quan Phan and Gerda Janssens.
<br>
<em>
Proceedings of the 23rd International Conference on Logic Programming,
</em>
Porto, Portugal, September 2007.
<p>
</li>

<li>
<strong>
<a href="papers.html#pbone-hons">
Calculating likely parallelism within dependent conjunctions
for logic programs.
</a>
</strong>
<br>
Paul Bone.
<em>
Honours report,
</em>
Melbourne, 2008.
<p>
</li>

<li>
<strong>
<a href="papers.html#packrat-padl08">
DCGs + memoing = packrat parsing; but is it worth it?
</a>
</strong>
<br>
Ralph Becket and Zoltan Somogyi,
<em>
Proceedings of the Tenth International Symposium
on Practical Aspects of Declarative languages,
</em>
San Francisco, California, January 2008.
<p>
</li>

<li>
<strong>
<a href="papers.html#lmika-hons">
Software transactional memory in Mercury.
</a>
</strong>
<br>
Leon Mika.
<em>
Honours report,
</em>
Melbourne, 2007.
<p>
</li>

<li>
<strong>
<a href="papers.html#exo-ciclops07">
Dealing with large predicates: exo-compilation in the WAM and in Mercury.
</a>
</strong>
<br>
Bart Demoen, Phuong-Lan Nguyen, Vitor Santos Costa and Zoltan Somogyi,
<em>
Proceedings of the Seventh International Colloquium
on Implementation of Constraint and Logic Programming Systems,
</em>
Porto, Portugal, September 2007.
<p>
</li>

<li>
<strong>
<a href="papers.html#wangp-hons">
Parallel Mercury.
</a>
</strong>
<br>
Peter Wang.
<em>
Honours report,
</em>
Melbourne, 2006.
<p>
</li>

<li>
<strong>
<a href="papers.html#padl06solver">
Adding constraint solving to Mercury.
</a>
</strong>
<br>
Ralph Becket, Maria Garcia de la Banda, Kim Marriott, Zoltan Somogyi,
Peter J. Stuckey and Mark Wallace,
<em>
Proceedings of the Eighth International Symposium
on Practical Aspects of Declarative languages,
</em>
Charleston, South Carolina, January 2006.
<p>
</li>

<li>
<strong>
<a href="papers.html#padl06dd">
Controlling search space materialization
in a practical declarative debugger.
</a>
</strong>
<br>
Ian MacLarty and Zoltan Somogyi,
<em>
Proceedings of the Eighth International Symposium
on Practical Aspects of Declarative languages,
</em>
Charleston, South Carolina, January 2006.
<p>
</li>

<li>
<strong>
<a href="papers.html#padl06tabling">
Tabling in Mercury: design and implementation.
</a>
</strong>
<br>
Zoltan Somogyi and Konstantinos Sagonas,
<em>
Proceedings of the Eighth International Symposium
on Practical Aspects of Declarative languages,
</em>
Charleston, South Carolina, January 2006.
<p>
</li>

<li>
<strong>
<a href="papers.html#maclarty-masters">
Practical declarative debugging of Mercury programs.
</a>
</strong>
<br>
Ian MacLarty.
<em>
Masters thesis,
</em>
University of Melbourne, July 2005.
<p>
</li>

<li>
<strong>
<a href="papers.html#ciclops05">
The implementation of minimal model tabling in Mercury (extended abstract).
</a>
</strong>
<br>
Zoltan Somogyi and Konstantinos Sagonas,
<em>
Colloquium on Implementation of Constraint and Logic Programming Systems,
</em>
Barcelona, Spain, October 2005.
<p>
</li>

<li>
<strong>
<a href="papers.html#dd3">
Divide-and-query and subterm dependency tracking
in the Mercury declarative debugger.
</a>
</strong>
<br>
Ian MacLarty, Zoltan Somogyi and Mark Brown.
<em>
Sixth International Symposium on
Automated and Analysis-driven Debugging,
</em>
Monterey, California, September 2005.
<p>
</li>

<li>
<strong>
<a href="papers.html#decl_debug">
Annotated event traces for declarative debugging.
</a>
</strong>
<br>
Mark Brown and Zoltan Somogyi
<em>
Unpublished,
</em>
Melbourne, 2005.
<p>
</li>

<li>
<strong>
<a href="papers.html#mazur-thesis">
Compile-time garbage collection for the declarative language Mercury.
</a>
</strong>
<br>
Nancy Mazur.
<em>
Ph.D. thesis,
</em>
Catholic University of Leuven, Belgium, May 2004.
<p>
</li>

<li>
<strong>
<a href="papers.html#dmo-thesis">
Precise and expressive mode systems for typed logic programming languages.
</a>
</strong>
<br>
David Overton.
<em>
Ph.D. thesis,
</em>
Melbourne, 2003.
<p>
</li>

<li>
<strong>
<a href="papers.html#aadebug03-paper">
Idempotent I/O for safe time travel.
</a>
</strong>
<br>
Zoltan Somogyi.
<em>
Proceedings of the Fifth International Workshop on Automated Debugging,
</em>
Ghent, Belgium, September 2003.
<p>
</li>

<li>
<strong>
<a href="papers.html#juliensf-hons">
Termination analysis for Mercury using convex constraints.
</a>
</strong>
<br>
Julien Fischer.
<em>
Honours report,
</em>
Melbourne, 2002.
<p>
</li>

<li>
<strong>
<a href="papers.html#conway-thesis">
Towards parallel Mercury.
</a>
</strong>
<br>
Thomas Conway.
<em>
Ph.D. thesis,
</em>
Melbourne, 2002.
<p>
</li>

<li>
<strong>
<a href="#dgj-thesis-final">
Expressive type systems for logic programming languages.
</a>
</strong>
<br>
David Jeffery.
<em>
Ph.D. thesis,
</em>
Melbourne,
2002.
<p>
</li>

<li>
<strong>
<a href="#p33-overton">
Constraint-based mode analysis of Mercury.
</a>
</strong>
<br>
David Overton, Zoltan Somogyi and Peter Stuckey.
<em>PPDP'02</em>, Pittsburgh.
<p>
</li>

<li>
<strong>
<a href="papers.html#p81-somogyi">
Using the heap to eliminate stack accesses.
</a>
</strong>
<br>
Zoltan Somogyi and Peter Stuckey.
<em>PPDP'02</em>, Pittsburgh.
<p>
</li>

<li>
<strong>
<a href="papers.html#high_level_gc">
Accurate garbage collection in an uncooperative environment.
</a>
</strong>
<br>
Fergus Henderson.
<em>ISMM'02</em>, Berlin.
<p>
</li>

<li>
<strong>
<a href="papers.html#mercury_to_clr">
Compiling Mercury to the .NET Common Language Runtime.
</a>
</strong>
<br>
Tyson Dowd, Fergus Henderson, and Peter Ross.
<em>BABEL'01</em>, Firenze, Italy.  To appear in <em>ENTCS 59.1</em>.
<p>
</li>

<li>
<strong>
<a href="papers.html#hlc_cc">
Compiling Mercury to high-level C code.
</a>
</strong>
<br>
Fergus Henderson and Zoltan Somogyi.
<em>CC'02</em>, Grenoble, France.
<p>
</li>

<li>
<strong>
<a href="papers.html#mu_01_24">
Deep profiling:
engineering a profiler for a declarative programming language.
</a>
</strong>
<br>
Thomas C. Conway and Zoltan Somogyi.
<em>Tech Report 2001/24</em>, Melbourne.
<p>
</li>

<li>
<strong>
<a href="papers.html#iclp2001_ctgc">
Practical aspects for a working compile time garbage collection system
for Mercury.
</a>
</strong>
<br>
Nancy Mazur, Peter Ross, Gerda Janssens and Maurice Bruynooghe.
<em>ICLP'01</em>, Paphos, Cyprus. <em>LNCS 2237</em>.
<p>
</li>

<li>
<strong>
<a href="papers.html#bta_higher_order">
Binding-time analysis by constraint solving: a modular and
higher-order approach for Mercury.
</a>
</strong>
<br>
Wim Vanhoof.
<em>LPAR'00</em>, Reunion Island, France. <em>LNCS 1955</em>.
<p>
</li>

<li>
<strong>
<a href="papers.html#memory_reuse_analysis">
A module based analysis for memory reuse in Mercury.
</a>
</strong>
<br>
Nancy Mazur, Gerda Janssens and Maurice Bruynooghe.
<em>ICCL'00</em>, London.  <em>LNAI</em>.
<p>
</li>

<li>
<strong>
<a href="papers.html#tail_lopstr_lncs">
Making Mercury programs tail recursive.
</a>
</strong>
<br>
Peter Ross, David Overton and Zoltan Somogyi.
<em>LOPSTR'99</em>, Venice, Italy.  <em>LNCS</em>.
<p>
</li>

<li>
<strong>
<a href="papers.html#update">
State update transformation.
</a>
</strong>
<br>
Peter Ross and Zoltan Somogyi.
<p>
</li>

<li>
<strong>
<a href="papers.html#purity">
Using impurity to create declarative interfaces in Mercury.
</a>
</strong>
<br>
Tyson Dowd, Peter Schachte, Fergus Henderson and Zoltan Somogyi.
<em>Tech Report 2000/17</em>, Melbourne, 2000.
<p>
</li>

<li>
<strong>
<a href="papers.html#liveness">
Towards memory reuse for Mercury.
</a>
</strong>
<br>
Nancy Mazur, Gerda Janssens and Maurice Bruynooghe.
<em>IDL'99</em>, Paris.
<p>
</li>

<li>
<strong>
<a href="papers/bta_higher_order.ps.gz">
Binding-time analysis for Mercury.
</a>
</strong>
<br>
Wim Vanhoof and Maurice Bruynooghe.
<em>ICLP'99</em>, Las Cruces, New Mexico
<p>
</li>

<li>
<strong>
<a href="papers.html#debugger_wlpe99">
The implementation technology of the Mercury debugger.
</a>
</strong>
<br>
Zoltan Somogyi and Fergus Henderson.
<em>WLPE'99</em>, Las Cruces, New Mexico.
<p>
</li>

<li>
<strong>
<a href="papers.html#tail_lopstr">
Making Mercury programs tail recursive (extended abstract).
</a>
</strong>
<br>
Peter Ross, David Overton and Zoltan Somogyi.
<em>LOPSTR'99</em>, Venice, Italy.
<p>
</li>

<li>
<strong>
<a href="papers.html#rtti_ppdp">
Run time type information in Mercury.
</a>
</strong>
<br>
Tyson Dowd, Zoltan Somogyi, Fergus Henderson, Thomas Conway and David Jeffery.
<br>
<em>PPDP'99</em>, Paris. <em>LNCS 1702</em>.
<p>
</li>

<li>
<strong>
<a href="papers.html#stayl_hons">
Optimization of Mercury programs.
</a>
</strong>
<br>
Simon Taylor.
<em>Honours report</em>, Melbourne, 1998.
<p>
</li>

<li>
<strong>
<a href="papers.html#mcorba_padl99">
MCORBA: A CORBA Binding for Mercury.
</a>
</strong>
<br>
David Jeffery, Tyson Dowd and Zoltan Somogyi.
<em>PADL'99</em>, San Antonio, Texas.  <em>LNCS 1551</em>.
<p>
</li>

<li>
<strong>
<a href="papers.html#mu_98_13">
Type classes in Mercury.
</a>
</strong>
<br>
David Jeffery, Fergus Henderson and Zoltan Somogyi.
<em>Tech Report 98/13</em>, Melbourne, 1998.
<p>
</li>

<li>
<strong>
<a href="papers.html#sas97">
Termination analysis for Mercury.
</a>
</strong>
<br>
Chris Speirs, Zoltan Somogyi and Harald Sondergaard.
<em>SAS'97</em>, Paris.
<p>
</li>

<li>
<strong>
<a href="papers.html#jicslpw">
Status of the Mercury system.
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson, Thomas Conway, Andrew Bromage,
Tyson Dowd, David Jeffery, Peter Ross, Peter Schachte and Simon Taylor.
<em>JICSLP'96 implementation workshop</em>, Bonn, Germany.
<p>
</li>

<li>
<strong>
<a href="papers.html#jlp">
The execution algorithm of Mercury:
an efficient purely declarative logic programming language.
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
<em>JLP</em>, 1996.
<p>
</li>

<li>
<strong>
<a href="papers.html#acsc96">
Determinism analysis in the Mercury compiler.
</a>
</strong>
<br>
Fergus Henderson, Zoltan Somogyi and Thomas Conway.
<br>
<em>ACSC'96</em>, Melbourne.
<p>
</li>

<li>
<strong>
<a href="papers.html#code_gen_mit">
Code generation for Mercury.
</a>
</strong>
<br>
Thomas Conway, Fergus Henderson, and Zoltan Somogyi.
<br>
<em>ILPS'95</em>, Portland, Oregon.
<p>
</li>

<li>
<strong>
<a href="papers.html#mercury_to_c">
Compiling logic programs to C
using GNU C as a portable assembler.
</a>
</strong>
<br>
Fergus Henderson, Zoltan Somogyi and Thomas Conway.
<em>ILPS'95 implementation workshop</em>,
Portland, Oregon.
<p>
</li>

<li>
<strong>
<a href="papers.html#acsc95">
Mercury: an efficient purely declarative logic programming language.
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
<em>ASCS'95</em>, Glenelg, Australia.
<p>
</li>

<li>
<strong>
<a href="papers.html#ilps94w">
The implementation of Mercury:
an efficient purely declarative logic programming language.
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
<em>
ILPS'94 Postconference Workshop on
Implementation Techniques for Logic Programming Languages,
</em>
Syracuse, New York.
<p>
</li>

<li>
<strong>
<a href="papers.html#conway_hons">
Code generation for Mercury.
</a>
</strong>
<br>
Thomas Conway.
<em>Honours report</em>, Melbourne, 1994.
<p>
</li>

</ul>

<h3><a href="papers.html#related">Related papers</a></h3>

<ul class="nonindentlist">
<li>
<strong>
<a href="papers.html#mc_swese_2007">
Ontology driven software engineering for real life applications.
</a>
</strong>
<br>
Michel Vanden Bossche, Peter Ross, Ian MacLarty, Bert Van Nuffelen,
Nikolay Pelov.
<em>
3rd International Workshop on Semantic Web Enabled
Software Engineering (SWESE 2007)
</em>
Innsbruck, Austria, 2007.
<p>
</li>

<li>
<strong>
<a href="papers.html#mu_97_23">
Termination analysis for logic programs.
</a>
</strong>
<br>
Chris Speirs.
<em>Technical Report 97/23</em>, Melbourne, 1997.
<p>
</li>

<li>
<strong>
<a href="papers.html#vision">
Logic programming for the real world.
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson, Thomas Conway and Richard O'Keefe.
<em>ILPS'95 ``visions'' workshop</em>, Portland, Oregon.
<p>
</li>

<li>
<strong>
<a href="papers.html#iclp87">
A system of precise modes for logic programs.
</a>
</strong>
<br>
Zoltan Somogyi.
<em>ICLP'87</em>, Melbourne.
<p>
</li>

<li>
<strong>
<a href="papers.html#zs_phd_thesis">
A parallel logic programming system based on strong and precise modes.
</a>
</strong>
<br>
Zoltan Somogyi.
<br>
<em>
Ph.D. Thesis.
</em>
Department of Computer Science,
The University of Melbourne.
<p>
</li>

<li>
<strong>
<a href="papers.html#fjh_hons_thesis">
Strong modes can change the world!
</a>
</strong>
Fergus Henderson.
<br>
<em>Honours Report</em>, Melbourne, 1993.
<p>
</li>

<li>
<strong>
<a href="papers.html#mu_96_45">
Database transactions in a purely declarative logic programming language.
</a>
</strong>
<br>
David B. Kemp, Thomas Conway, Evan Harris, Fergus Henderson,
Kotagiri Ramamohanarao and Zoltan Somogyi.
<em>Tech Report 96/45</em>, Melbourne, 1996.
<p>
</li>

<li>
<strong>
<a href="papers.html#tr90-2">
Right-, left-, and multi-linear rule transformations that maintain
context information.
</a>
</strong>
<br>
David B. Kemp and Kotagiri Ramamohanarao and Zoltan Somogyi.
<br>
<em>Tech Report 90/2</em>, Melbourne, 1997.
</li>

</ul>

<h3><a href="papers.html#presentations">Presentations</a></h3>

<ul class="nonindentlist">

<li>
<strong>
<a href="papers.html#subword_talk">
Packing sub-word-size arguments.
</a>
</strong>
<br>
Zoltan Somogyi.
<br>
<em>
YesLogic,
</em>
Melbourne, Australia, October 2018.
<p>
</li>

<li>
<strong>
<a href="papers.html#mfug_talk">
The Mercury Programming Language.
</a>
</strong>
<br>
Paul Bone, based on slides by Zoltan Somogyi.
<br>
<em>
<a href="http://www.meetup.com/Melbourne-Functional-User-Group-MFUG/">
Melbourne Functional User Group,
</a>
</em>
Melbourne, Australia, April 2015.
<p>
</li>

<li>
<strong>
<a href="papers.html#pbone_completion">
Automatic parallelism for Mercury.
</a>
</strong>
<br/>
Paul Bone.
<em>
Ph.D. Completion Seminar,
</em>
Department of Computing and Information Systems,
The University of Melbourne.
May 2012.
<p>
</li>

<li>
<strong>
<a href="papers.html#loop_control_talk">
Controlling Loops in Parallel Mercury Code.
</a>
</strong>
<br>
Paul Bone, Zoltan Somogyi and Peter Schachte.
<br>
<em>
Declarative Aspects and Applications of Multicore Programming
</em>
Philadelphia, Pennsylvania, USA, January 2012.
<a href="papers.html#loop_control">corresponding paper</a>
<p>
</li>

<li>
<strong>
<a href="papers.html#threadscope_talk">
Profiling parallel Mercury programs with ThreadScope..
</a>
</strong>
<br/>
Paul Bone and Zoltan Somogyi.
<em>
21st Workshop on Logic-based methods in Programming Environments.
</em>
Lexington, Kentucky, July 2011.
<a href="papers.html#threadscope">corresponding paper</a>
<p>
</li>

<li>
<strong>
<a href="papers.html#overlap_talk">
Estimating the overlap between dependent computations
for automatic parallelization.
</a>
</strong>
<br/>
Paul Bone, Zoltan Somogyi and Peter Schachte.
<em>
27th International. Conference on Logic Programming (ICLP'11)
</em>
Lexington, Kentucky, July 2011.
<a href="papers.html#overlap">corresponding paper</a>
<p>
</li>

<li>
<strong>
<a href="papers.html#dep_and_parallel_talk">
Minimizing the overheads of dependent AND-parallelism.
</a>
</strong>
<br/>
Peter Wang and Zoltan Somogyi.
<em>
27th International. Conference on Logic Programming (ICLP'11),
</em>
Lexington, Kentucky, July 2011.
<a href="papers.html#dep_and_parallel">corresponding paper</a>
<p>
</li>

<li>
<strong>
<a href="papers.html#luv_2011">
The Mercury project.
</a>
</strong>
<br/>
Zoltan Somogyi.
<em>
A presentation for the <a href="http://luv.asn.au">Linux Users of Victoria</a>
</em>
Melbourne Australia.
June 2011.
<p>
</li>

<li>
<strong>
<a href="papers.html#google_2010_autopar">
Automatic parallelisation for Mercury.
</a>
</strong>
<br/>
Paul Bone.
<em>
A Tech Talk at Google Sydney
and a seminar at The University of New South Wales,
</em>
Sydney Australia,
December 2010.
<p>
</li>

<li>
<strong>
<a href="papers.html#linuxconf_2010_autopar">
Automatic parallelisation in Mercury.
</a>
</strong>
<br/>
Paul Bone.
<em>
Multicore Miniconference, Linuxconf Australia,
</em>
Wellington NZ, 
January 2010.
<p>
</li>

<li>
<strong>
<a href="papers.html#leuven09">
Towards automatic parallelization of Mercury programs.
</a>
</strong>
<br>
Zoltan Somogyi
<em>
Catholic University of Leuven,
Belgium,
</em>
17 November 2009.
<p>
</li>

<li>
<strong>
<a href="papers.html#fpu_rules_2009">
Writing business rules engines in Mercury.
</a>
</strong>
<br>
Ian MacLarty
<em>
Functional Programming Union,
University of Melbourne,
</em>
24 July 2009.
<p>
</li>

<li>
<strong>
<a href="papers.html#mc_owl_mercury_talk_14_08_2007">
Ontology driven software development with Mercury.
</a>
</strong>
<br>
Ian MacLarty, Peter Ross.
<em>
University of Melbourne,
</em>
14 August 2007.
<p>
</li>

<li>
<strong>
<a href="papers.html#g12_unclean">
Unclean! Unclean! or Purity issues in declarative constraint logic programming.
</a>
</strong>
<br>
Ralph Becket.
University of Melbourne, 28 March 2006.
<p>
</li>

<li>
<strong>
<a href="papers.html#aadebug05-talk">
Divide-and-query and subterm dependency tracking
in the Mercury declarative debugger.
</a>
</strong>
<br>
Ian MacLarty, Zoltan Somogyi and Mark Brown.
Talk presented at the Sixth International
Symposium on Automated and Analysis Driven Debugging,
Monterey, USA, September 2005.
<p>
</li>

<li>
<strong>
<a href="papers.html#aadebug03-talk">
Idempotent I/O for safe time travel.
</a>
</strong>
<br>
Zoltan Somogyi.
Invited talk presented at
the Fifth International Workshop on Automated Debugging,
Ghent, Belgium, September 2003.
<p>
</li>

<li>
<strong>
<a href="papers.html#ppdp02mode-talk">
Constraint-based mode analysis of Mercury.
</a>
</strong>
<br>
David Overton, Zoltan Somogyi and Peter J. Stuckey.
Talk presented at Fourth International Conference
on Principles and Practice of Declarative Programming.
Pittsburgh, Pennsylvania, October 2002.
<p>
</li>

<li>
<strong>
<a href="papers.html#ppdp02stack-talk">
Using the heap to eliminate stack accesses.
</a>
</strong>
<br>
Zoltan Somogyi and Peter J. Stuckey.
Talk presented at Fourth International Conference
on Principles and Practice of Declarative Programming.
Pittsburgh, Pennsylvania, October 2002.
<p>
</li>

<li>
<strong>
<a href="papers.html#sas_talk">
Termination analysis for Mercury.
</a>
</strong>
<br>
Chris Speirs, Zoltan Somogyi and Harald Sondergaard.
Talk presented at <em>SAS'97</em>, Paris.
<p>
</li>

<li>
<strong>
<a href="papers.html#unif">
Unification in Mercury.
</a>
</strong>
<br>
Zoltan Somogyi.
<em>
Invited talk presented at the Eighth Benelux Workshop on Logic Programming,
</em>
Louvain-la-Neuve, Belgium, 1996.
<p>
</li>

<li>
<strong>
<a href="papers.html#jicslp_talk">
The design and implementation of Mercury.
</a>
</strong>
<br>
Zoltan Somogyi and Fergus Henderson.
Tutorial presented at <em>JICSLP'96</em>, Bonn, Germany.
<p>
</li>

<li>
<strong>
<a href="papers.html#jicslpw_talk">
Status of the Mercury system.
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson, Thomas Conway, Andrew Bromage,
Tyson Dowd, David Jeffery, Peter Ross, Peter Schachte and Simon Taylor.
<br>
Presented at <em>the JICSLP '96 Workshop on Parallelism and
Implementation Technology for (Constraint) Logic Programming Languages,
</em>
Bonn, Germany.
<p>
</li>

<li>
<strong>
<a href="papers.html#acsc95_slides">
Mercury:
an efficient purely declarative logic programming language.
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
Presented at <em>ACSC'95</em>, Adelaide, South Australia.
<p>
</li>

<li>
<strong>
<a href="papers.html#257_1999">
Mercury lecture notes for 433-257 (expanded).
</a>
</strong>
<br>
Zoltan Somogyi, 1999.
<p>
</li>

<li>
<strong>
<a href="papers.html#257">
Mercury lecture notes for 433-257.
</a>
</strong>
<br>
Zoltan Somogyi, 1997.
<p>
</li>

<li>
<strong>
<a href="papers.html#247">
Mercury lecture notes for 433-247.
</a>
</strong>
<br>
Zoltan Somogyi, 1995.
<p>
</li>

<li>
<strong>
<a href="papers.html#dgj-talk">
Type classes for logic programming languages.
</a>
</strong>
<br>
David Jeffery, 1998.
<p>
</li>

<li>
<strong>
<a href="papers.html#rtti_talk_98">
Runtime type information in Mercury.
</a>
</strong>
<br>
Tyson Dowd, 1998.
<p>
</li>

</ul>

<hr>

<h2><a name="mercury">Papers on Mercury</a></h2>

<ul class="nonindentlist">

<li>
<strong>
<a name="pbone_phd_thesis">
Automatic parallelisation for Mercury.
</a>
</strong>
<br>
Paul Bone.
<br>
<em>
Ph.D. Thesis,
</em>
Department of Computing and Information Systems,
The University of Melbourne,
December 2012.
<br>
Available here
<a href="papers/pbone_phd_thesis.pdf">
as PDF (2.0M).
</a>
<p>
Multicore computing is ubiquitous, so programmers need to write parallel
programs to take advantage of the full power of modern computer systems.
However, the most popular parallel programming methods are difficult and
extremely error-prone. Most such errors are intermittent, which means they
may be unnoticed until after a product has been shipped; they are also often
very difficult to fix. This problem has been addressed by pure declarative
languages that support explicit parallelism. However, this does nothing
about another problem: it is often difficult for developers to find tasks
that are worth parallelising. When they can be found, it is often too easy
to create too much parallelism, such that the overheads of parallel
execution overwhelm the benefits gained from the parallelism. Also, when
parallel tasks depend on other parallel tasks, the dependencies may restrict
the amount of parallelism available. This makes it even harder for
programmers to estimate the benefit of parallel execution.
</p>
<p>
In this dissertation we describe our profile feedback directed automatic
parallelisation system, which aims at solving this problem. We implemented
this system for Mercury, a pure declarative logic programming language. We
use information gathered from a profile collected from a sequential
execution of a program to inform the compiler about how that program can be
parallelised. Ours is, as far as we know, the first automatic
parallelisation system that can estimate the parallelism available among any
number of parallel tasks with any number of (non-cyclic) dependencies. This
novel estimation algorithm is supplemented by an efficient exploration of
the program’s call graph, an analysis that calculates the cost of recursive
calls (as this is not provided by the profiler), and an efficient search for
the best parallelisation of N computations from among the 2<sup>N−1</sup>
candidates.
</p>
<p>
We found that in some cases where our system parallelised a loop, spawning
off virtually all of its iterations, the resulting programs exhibited
excessive memory usage and poor performance.  We therefore designed and
implemented a novel program transformation that fixes this problem.  Our
transformation allows programs to gain large improvements in performance and
in several cases, almost perfect linear speedups. The transformation also
allows recursive calls within the parallelised code to take advantage of
tail recursion.
</p>
<p>
Also presented in this dissertation are many changes that improve the
performance of Mercury’s parallel runtime system, as well as a proposal and
partial implementation of a visualisation tool that assists developers with
parallelising their programs, and helps researchers develop automatic
parallelisation tools and improve the performance of the runtime system.
</p>
<p>
Overall, we have attacked and solved a number of issues that are critical to
making automatic parallelism a realistic option for developers.
</p>
<p>
<code>
<pre>
@PhdThesis{bone12:autoparallelism_thesis,
  author =       {Paul Bone},
  title =        {Automatic Parallelisation for Mercury},
  school =       {Department of Computing and Information Systems,
                  The University of Melbourne},
  year =         {2012},
  address =      {Australia},
  month =        {Decemeber}
}
</pre>
</code>
</p>
</li>

<li>
<strong>
<a name="loop_control">
Controlling loops in parallel Mercury code.
</a>
</strong>
<br>
Paul Bone, Zoltan Somogyi and Peter Schachte
<br>
<em>
Declarative Aspects and Applications of Multicore Programming
</em>
Philadelphia, Pennsylvania, USA, January 2012.
<br>
Available here
<a href="papers/loop_control.pdf">
as PDF (159K).
</a>
<p>
Recently we built a system that uses profiling data
to automatically parallelize Mercury programs by
finding conjunctions with expensive conjuncts
that can run in parallel with minimal synchronization delays.
This worked very well in many cases, but in cases of tail recursion,
we got much lower speedups than we expected,
due to excessive memory usage.
In this paper, we present a novel program transformation
that eliminates this problem,
and also allows recursive calls inside parallel conjunctions
to take advantage of tail recursion optimization.
Our benchmark results show that our new transformation
greatly increases the speedups we can get from parallel Mercury programs;
in one case, it changes no speedup into almost perfect speedup on four cores.
<p>
<code>
<pre>
@InProceedings{bone12:_contr_loops_paral_mercur_code,
  author =       {Paul Bone and Zoltan Somogyi and Peter Schachte},
  title =        {Controlling Loops in Parallel Mercury Code},
  booktitle = {Declarative Aspects and Applications of Multicore Programming},
  year =      2012,
  address =   {Philadelphia, PA, USA},
  month =     {January}
}
</pre>
</code>
</p>
</li>

<li>
<strong>
<a name="threadscope">
Profiling parallel Mercury programs with ThreadScope.
</a>
</strong>
<br>
Paul Bone and Zoltan Somogyi.
<br>
<em>
21st Workshop on Logic-based methods in Programming Environments.
</em>
Lexington, Kentucky, July 2011.
<br>
Available here
<a href="papers/threadscope.pdf">
as PDF (429K).
</a>
<p>
The behavior of parallel programs is even harder to understand than the
behavior of sequential programs. Parallel programs may suffer from any of the
performance problems affecting sequential programs, as well as from several
problems unique to parallel systems. Many of these problems are quite hard (or
even practically impossible) to diagnose without help from specialized tools.
We present a proposal for a tool for profiling the parallel execution of
Mercury programs, a proposal whose implementation we have already started. This
tool is an adaptation and extension of the ThreadScope profiler that was first
built to help programmers visualize the execution of parallel Haskell programs.
<p>
<code>
<pre>
@inprocedings{bone-somogyi_2011_threadscope,
    author = {Paul Bone and Zoltan Somogyi},
    title = {Profiling parallel {M}ercury programs with {T}hread{S}cope},
    booktitle = {21st Workshop on Logic-based methods in Programming Environments (WLPE 2011)},
    year = {2011},
    month = {July},
    editor = {Peter Schneider-Kamp},
    pages = {32--46},
}
</pre>
</code>
</p>
</li>

<li>
<strong>
<a name="overlap">
Estimating the overlap between dependent computations
for automatic parallelization.
</a>
</strong>
<br>
Paul Bone, Zoltan Somogyi and Peter Schachte.
<br>
<em>
Theory and Practice of Logic Programming, 27th Int'l. Conference on Logic
Programming (ICLP'11) Special Issue, volume 11, issue 4-5.
</em>
Lexington, Kentucky, July 2011.
<br>
Available here
<a href="papers/dep_par_conj_overlap.ps">
as PostScript (959K).
</a>
and
<a href="papers/dep_par_conj_overlap.pdf">
as PDF (196K).
</a>
<p>
Researchers working on the automatic parallelization of programs
have long known that too much parallelism
can be even worse for performance than too little,
because spawning a task to be run on another CPU incurs overheads.
Autoparallelizing compilers have therefore
long tried to use granularity analysis
to ensure that they only spawn off computations
whose cost will probably exceed the spawn-off cost by a comfortable margin.
However, this is not enough to yield good results,
because data dependencies may <em>also</em> limit
the usefulness of running computations in parallel.
If one computation blocks almost immediately
and can resume only after another has completed its work,
then the cost of parallelization again exceeds the benefit.
</p>
<p>
We present a set of algorithms for recognizing places in a program
where it is worthwhile to execute two or more computations in parallel
that pay attention to the second of these issues as well as the first.
Our system uses profiling information to compute
the times at which a procedure call consumes the values of its input arguments
and the times at which it produces the values of its output arguments.
Given two calls that may be executed in parallel,
our system uses the times of production and consumption
of the variables they share
to determine how much their executions would overlap
if they were run in parallel,
and therefore whether executing them in parallel is a good idea or not.
</p>
<p>
We have implemented this technique for Mercury
in the form of a tool that uses profiling data
to generate recommendations about what to parallelize,
for the Mercury compiler to apply on the next compilation of the program.
We present preliminary results that show that
this technique can yield useful parallelization speedups,
while requiring nothing more from the programmer
</p>
<p>
<code>
<pre>
@article{bone-somogyi-schachte_2011_overlap,
    author = {Paul Bone and Zoltan Somogyi and Peter Schachte},
    title = {Estimating the overlap between dependent computations
             for automatic parallelization},
    journal = {Theory and Practice of Logic Programming, 27th Int’l.
               Conference on Logic Programming (ICLP’11) Special Issue},
    year = {2011},
    month = {July},
    publisher = {Cambridge University Press},
    volume = {11},
    number = {(4--5)},
    pages = {575--587}
}
</pre>
</code>
</p>
</li>

<li>
<strong>
<a name="dep_and_parallel">
Minimizing the overheads of dependent AND-parallelism.
</a>
</strong>
<br>
Peter Wang and Zoltan Somogyi.
<br>
<em>
Technical Communications of the 27th International Conference on Logic
Programming (ICLP'11), LIPICS Vol. 11.
</em>
Lexington, Kentucky, July 2011.
<br>
Available here
<a href="papers/minimizing_overheads_short.ps">
as PostScript (836K).
</a>
and
<a href="papers/minimizing_overheads_short.pdf">
as PDF (447K).
</a>
A longer version, with more details,
is available here
<a href="papers/minimizing_overheads_long.ps">
as PostScript (898K).
</a>
and
<a href="papers/minimizing_overheads_long.pdf">
as PDF (179K).
</a>
<p>
Parallel implementations of programming languages
need to control synchronization overheads.
Synchronization is essential
for ensuring the correctness of parallel code,
yet it adds overheads that aren't present in sequential programs.
This is an important problem for parallel logic programming systems,
because almost every action in such programs requires accessing variables,
and the traditional approach of adding synchronization code
to all such accesses is so prohibitively expensive that
a parallel version of the program may run more slowly on four processors
than a sequential version would run on one processor.
We present a program transformation for implementing
dependent AND-parallelism in logic programming languages
that uses mode information to add synchronization code
only to the variable accesses that actually need it.
<p>
<code>
<pre>
@inproceedings{wang-somogyi_2011_dep-par-conj,
    author = {Peter Wang and Zoltan Somogyi},
    title = {Minimizing the overheads of dependent {AND}-parallelism},
    booktitle = {Technical Communications of the 27th Int’l. Conference on
                 Logic Programming (ICLP’11)},
    pages = {128-138},
    volume = {11},
    year = {2011},
    month = {July},
    publisher = {Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
    series = {Leibniz International Proceedings in Informatics (LIPIcs)},
}
</pre>
</code>
</p>
</li>

<li>
<strong>
<a name="bmellor-hons">
Towards software transactional memory for real-world programs.
</a>
</strong>
<br/>
Ben Mellor.
<br/>
<em>
Honours report,
</em>
Department of Computer Science and Software Engineering,
The University of Melbourne,
October 2009.
<br>
<a href="papers/bmellor_hons.pdf">
Available here (533K).
</a>
<p>
Parallel programming is becoming more and more important as commonly available
machines begin to grow in their capability for parallel execution. Parallel
streams of execution that operate on shared data to achieve a common task need
to be carefully synchronised. The standard way of achieving this
synchronisation is to use locks, but lock-based programming is difficult and
error-prone, making parallel programs costly and unreliable.
</p>
<p>
Another method of providing synchronised access to shared data is the
transactional memory model. Software Transactional Memory (STM), implementing
this model purely in software and thus compatible with today's hardware, has
been an area of much research in the last decade.
</p>
<p>
This report describes the implementation of a sophisticated STM system using
recently developed techniques as well as novel innovations. This implementation
is for the logic programming language Mercury, building on an earlier and
simpler STM implementation.
</p>
</li>

<li>
<strong>
<a name="quan-phd">
Region-based memory management for the logic programming language Mercury.
</a>
</strong>
<br>
Quan Phan.
<br>
<em>
Ph.D. thesis
</em>
Department of Computer Science,
Catholic University of Leuven (KUL),
November 2009.
<br>
<a href="papers/quan_thesis.pdf">
Available here (919K).
</a>
<p>
Region-based memory management (RBMM)
is a form of compile-time memory management,
well-known from the functional programming world.
In this thesis we describe our work of investigating and developing RBMM
for the logic programming language Mercury.
Mercury is designed with
strong type, mode, and determinism systems.
These systems not only provide Mercury programmers
with several direct software engineering benefits,
such as self-documenting code and clear program logic,
but also give the language developers useful information for optimizations.
</p>
<p>
The first challenge in realizing RBMM for a programming language
is to divide program data into regions
such that the regions can be reclaimed as soon as possible.
In the thesis we have developed program analyses
that determine the distribution of data over regions as well as
their lifetimes in a Mercury program.
The program then is transformed to a region-annotated program
containing the necessary region constructs.
We provide the correctness proofs of the related program analyses and
transformation, which guarantee the safeness of memory accesses
in annotated programs.
</p>
<p>
We have implemented runtime support
that tackles the special challenge posed by backtracking.
Backtracking can require regions
removed during forward execution to be ``resurrected'',
and any memory allocated during a computation that has been backtracked over
must be recovered promptly,
without waiting for the regions involved to come to the end of their life.
</p>
<p>
We study the effects of RBMM for a selection of benchmark programs
including well-known difficult cases for RBMM.
Our RBMM-enabled Mercury system
obtains clearly faster runtime for two third of the benchmarks compared to
the Mercury system using the Boehm runtime garbage collector,
with an average speedup of 20%.
In terms of memory usage,
the region system achieves optimal memory consumption in some programs.
Our in-depth case study reveals the impact of sharing on memory reuse
in programs in region-based systems.
</p>
<p>
Finally, we propose region reuse extension to our current region framework.
Our RBMM system augmented with region reuse
can automatically improve memory reuse for a popular class of programs
that otherwise often require non-intuitive manual program-rewriting
so that RBMM systems can obtain good memory reuse.
</p>
</li>

<li>
<strong>
<a name="more-precise-rbmm">
More precise region-based memory management for Mercury programs.
</a>
</strong>
<br>
Quan Phan and Gerda Janssens.
<br>
<em>
Proceedings of the Ninth International Colloquium on
Implementation of Constraint and Logic Programming Systems (CICLOPS '09),
</em>
Pasadena, California, July 2009, pages 1-15.
<br>
<a href="papers/ciclops09.pdf">
Available here (200K).
</a>
<p>
Dividing the heap memory of programs into regions is
the starting point of region-based memory management.
In our existing work of
enabling region-based memory management for Mercury,
a program analysis was used to distribute data over the regions.
An important goal of the analysis is to decide
which program variables should end up in the same region.
For a popular class of programs,
it covetously puts program variables in the same region,
while more memory could have been reused
if they had been kept in separate ones.
In this paper we define a new refined region analysis
that is keen to keep program variables in separate regions
by taking into account the different execution paths of a procedure.
With the more precise, path-sensitive analysis we
can reduce the memory footprint for several programs.
</p>
</li>

<li>
<strong>
<a name="path-sensitive-ppdp">
Path-sensitive region analysis for Mercury programs.
</a>
</strong>
<br>
Quan Phan and Gerda Janssens.
<br>
<em>
Proceedings of 11th International Symposium on
Principles and Practice of Declarative Programming,
</em>
Coimbra, Portugal, September 2009, pages 161-169.
<br>
<a href="papers/ppdp14-phan.pdf">
Available here (215K).
</a>
<p>
Dividing the heap memory of programs into regions is
the starting point of region-based memory management.
In our existing work of
enabling region-based memory management for Mercury,
a program analysis was used to distribute data over the regions.
An important goal of the analysis is to decide
which program variables should end up in the same region.
For a popular class of programs,
it covetously puts program variables in the same region,
while more memory could have been reused
if they had been kept in separate ones.
In this paper we define a new refined region analysis
that is keen to keep program variables in separate regions
by taking into account the different execution paths of a procedure.
With the more precise, path-sensitive analysis we
can reduce the memory footprint for several programs.
</p>
</li>

<li>
<strong>
<a name="runtime-support-ismm08">
Runtime support for region-based memory management in Mercury.
</a>
</strong>
<br>
Quan Phan, Zoltan Somogyi and Gerda Janssens.
<br>
<em>
Proceedings of the 2008 International Symposim on Memory Management (ISMM '08),
</em>
Tucson, Arizona, June 2008, pages 61-70.
<br>
<a href="papers/ismm115-phan.pdf">
Available here (148K).
</a>
<p>
Applying region-based memory management (RBMM)
to logic programming languages poses a special challenge:
backtracking can require regions
removed during forward execution to be ``resurrected'',
and any memory allocated during a computation that has been backtracked over
must be recovered promptly,
without waiting for the regions involved to come to the end of their life.
In this paper, we describe how we implemented runtime support for RBMM
in the logic programming language Mercury,
whose specialized implementation
of the language constructs involved in backtracking
required equally specialized support.
Our benchmark Mercury programs run about 25% faster on average
with RBMM than with the usual Boehm garbage collector,
and for some programs, RBMM achieves optimal memory consumption.
</p>
</li>

<li>
<strong>
<a name="static-region-analysis">
Static region analysis for Mercury.
</a>
</strong>
<br>
Quan Phan and Gerda Janssens.
<br>
<em>
Proceedings of the 23rd International Conference on Logic Programming,
</em>
Porto, Portugal, September 2007, pages 317-332.
<br>
<a href="papers/iclp2007.pdf">
Available here (193K).
</a>
<p>
Region-based memory management is a form of compile-time memory
management, well-known from the functional programming world.
This paper describes a static region analysis for the logic
programming language Mercury. We use region points-to graphs to
model the partitioning of the memory used by a program into
separate regions. The algorithm starts with a region points-to
analysis that determines the different regions in the program. We then
compute the liveness of the regions by using an extended live
variable analysis. Finally, a program transformation adds region
annotations to the program for region support. These annotations generate
data for a region simulator that generates reports on the memory behaviour of
region-annotated programs. Our approach obtains good memory consumption
for several benchmark programs; for some of them it achieves optimal
memory management.
</p>
</li>

<li>
<strong>
<a name="pbone-hons">
Calculating likely parallelism within dependent conjunctions
for logic programs.
</a>
</strong>
<br>
Paul Bone.
<br>
<em>
Honours report,
</em>
Department of Computer Science and Software Engineering,
The University of Melbourne,
October 2008.
<br>
<a href="papers/pbone_hons.pdf">
Available here (265K).
</a>
<p>
The rate at which computers are becoming faster at sequential execution has
dropped significantly.  Instead parallel processing power is increasing, and
multicore computers are becoming more common.  Automatically parallelising
programs is becoming much more desirable.  Parallelising programs written in
imperative programming languages is difficult and often leads to unreliable
software.  Parallelising programs in declarative languages is easy, to the
extent that compilers are able to do this automatically.  However this often
leads to cases where the overheads of parallel execution outweigh the speedup
that might have been available by parallelising the program.
</p>
<p>
This thesis describes a new implicit parallelism implementation that calculates
the speedup due to parallelism in dependent conjunctions for Mercury --- a
purely declarative logic programming language.  This is done by analysing
profiling data and a representation of the program in order to determine when
during the execution of a parallel conjunct variables are likely to be produced
and consumed.  This enables us to calculate how long a conjunct may have to
wait for a variable to be produced, and how much parallelism is actually
available in a parallel conjunction.  This information should enable the
compiler to parallelise a program only in places where doing so is profitable.
</p>
<p>
We expect that two of the components we implemented for our implicit
parallelism analysis, coverage profiling and a generic feedback framework, will
also be quite useful in other applications.  For example this can help the
compiler select the best calls to inline.
</p>
</li>

<li>
<strong>
<a name="packrat-padl08">
DCGs + memoing = packrat parsing; but is it worth it?
</a>
</strong>
<br>
Ralph Becket and Zoltan Somogyi.
<em>
Proceedings of the Tenth International Symposium
on Practical Aspects of Declarative languages,
</em>
San Francisco, California, January 2008,
Springer Verlag, &copy;.
<br>
Available in
<a href="papers/packrat.pdf">
pdf (176k)
</a>
or
<a href="papers/packrat.ps.gz">
ps.gz (145k)
</a>
formats.
<p>
Packrat parsing is a newly popular technique
for efficiently implementing recursive descent parsers.
Packrat parsing avoids the potential exponential costs of
recursive descent parsing with backtracking
by ensuring that each production rule in the grammar
is tested at most once against each position in the input stream.
This paper argues that
<ul>
<li> packrat parsers can be trivially implemented
using a combination of definite clause grammar rules and memoing,
and that</li>
<li> packrat parsing may actually be significantly <em>less</em> efficient
than plain recursive descent with backtracking,
but</li>
<li> memoing the recognizers of just one or two nonterminals,
selected in accordance with Amdahl's law, can sometimes yield speedups.</li>
</ul>
</p>
<p>
We present experimental evidence to support these claims.
</p>
<p>
The benchmark data on which the performance evaluation section of this paper
is based is
<a href="papers/packrat.package.tar.gz">available here (2.6M)</a>.
</p>
</li>

<li>
<strong>
<a name="lmika-hons">
Software transactional memory in Mercury.
</a>
</strong>
<br>
Leon Mika.
<br>
<em>
Honours report,
</em>
Department of Computer Science and Software Engineering,
The University of Melbourne,
October 2007.
<br>
<a href="papers/lmika_hons.pdf">
Available here (220K).
</a>
<p>
Concurrent programming is now becoming more important than ever.
But for concurrent
programs to work deterministically, sections of the code must be synchronised.
The most common method of synchronising code is to protect the code with locks.
However, code which uses locks is difficult to write and even more difficult
to debug.
Locking also makes it difficult to compose large programs from smaller ones.
A relatively new method of synchronisation, known as Software Transactional
Memory, is promising to be a much easier method of synchronisation.
This thesis describes the design and implementation
of a Software Transactional Memory system in Mercury.
</p>
</li>

<li>
<strong>
<a name="exo-ciclops07">
Dealing with large predicates: exo-compilation in the WAM and in Mercury.
</a>
</strong>
<br>
Bart Demoen, Phuong-Lan Nguyen, Vitor Santos Costa and Zoltan Somogyi.
<em>
Proceedings of the Seventh International Colloquium
on Implementation of Constraint and Logic Programming Systems,
</em>
Porto, Portugal, September 2007.
<br>
<a href="papers/ciclops07.ps.gz">
Available here (156k).
</a>
<p>
Logic programming systems often need to deal with large but otherwise
regular predicates, e.g. wide ground facts. Such predicates can be
treated as any other predicate by the compiler, but there are good
reasons to treat them specially,
the most important being that
separating the code from the data really pays off.
We call the technique exo-compilation:
it reduces the memory needed for the code to about one third of the
normal WAM compilation schema without undue slowdown. As a bonus,
queries with lots of void variables get a significantly better
treatment.
</p>
<p>
We first introduce the idea of exo-compilation by an example
and present its implementation in hProlog.
We show
how other optimisations can be built on top of it,
and evaluate how it performs in practice.
We then show that the same ideas can also be applied
(albeit in a slightly different form)
to Mercury, whose implementation is based on very different principles.
</p>
</li>

<li>
<strong>
<a name="wangp-hons">
Parallel Mercury.
</a>
</strong>
<br>
Peter Wang.
<br>
<em>
Honours report,
</em>
Department of Computer Science and Software Engineering,
The University of Melbourne,
October 2006.
<br>
<a href="papers/wangp_hons.ps.gz">
Available here (216K).
</a>
<p>
Mercury is a purely declarative programming language that is highly
suited to parallel execution.
We present two main contributions towards parallel execution of
Mercury programs.
The first is a source-to-source transformation
that allows goals with dependencies to execute in parallel,
with no negative impact on code which doesn't make use of it.
The second is the design and implementation of a new parallel
execution mechanism that allows parallel code to execute far more
efficiently than in the existing Mercury implementation.
</p>
</li>

<li>
<strong>
<a name = "padl06solver">
Adding constraint solving to Mercury.
</a>
</strong>
<br>
Ralph Becket, Maria Garcia de la Banda, Kim Marriott, Zoltan Somogyi,
Peter J. Stuckey and Mark Wallace.
<em>
Proceedings of the Eighth International Symposium
on Practical Aspects of Declarative languages,
</em>
Charleston, South Carolina, January 2006,
Springer Verlag, &copy;.
<br>
Available in
<a href="papers/padl_solver.pdf">
pdf (166k)
</a>
or
<a href="papers/padl_solver.ps.gz">
ps.gz (139k)
</a>
formats.
<p>
The logic programming language Mercury
is designed to support programming in the large.
Programmer declarations in conjunction with
powerful compile-time analysis and optimization
allow Mercury programs to be very efficient.
The original design of Mercury
did not support constraint logic programming (CLP).
This paper describes the extensions we added to Mercury to support CLP.
Unlike similarly motivated extensions to Prolog systems,
our objectives included
preserving the purity of Mercury programs as much as possible,
as well as avoiding any impact
on the efficiency of non-CLP predicates and functions.
</p>
</li>

<li>
<strong>
<a name = "padl06dd">
Controlling search space materialization
in a practical declarative debugger.
</a>
</strong>
<br>
Ian MacLarty and Zoltan Somogyi.
<em>
Proceedings of the Eighth International Symposium
on Practical Aspects of Declarative languages,
</em>
Charleston, South Carolina, January 2006,
Springer Verlag, &copy;.
<br>
Available in
<a href="papers/padl_dd.pdf">
pdf (201k)
</a>
or
<a href="papers/padl_dd.ps.gz">
ps.gz (176k)
</a>
formats.
<p>
While the idea of declarative debugging
has been around for a quarter of a century,
the technology still hasn't been adopted by working programmers,
even by those working in declarative languages.
The reason is that making declarative debuggers practical
requires solutions to a whole host of problems.
In this paper we address one of these problems, which is that
retaining a complete record of every step of the execution of a program
is infeasible unless the program's runtime is very short,
yet this record forms the space searched by the declarative debugger.
Most parts of this search space
therefore have to be stored in an implicit form.
Each time the search algorithm visits
a previously unexplored region of the search space,
it must decide how big a part of the search space to rematerialize
(which it does by reexecuting a call in the program).
If it materializes too much, the machine may start to thrash
or even run out of memory and swap space.
If it materializes too little, then materializing
all the parts of the search space required by a debugging session
will require too many reexecutions of (parts of) the program,
which will take too long.
We present a simple algorithm, the <em>ideal depth strategy</em>,
for steering the ideal middle course:
minimizing reexecutions while limiting memory consumption to what is feasible.
We show that this algorithm performs well
even when used on quite long running programs.
</p>
</li>

<li>
<strong>
<a name = "padl06tabling">
Tabling in Mercury: design and implementation.
</a>
</strong>
<br>
Zoltan Somogyi and Konstantinos Sagonas.
<em>
Proceedings of the Eighth International Symposium
on Practical Aspects of Declarative languages,
</em>
Charleston, South Carolina, January 2006,
Springer Verlag, &copy;.
Available in
<a href="papers/padl_tabling.pdf">
pdf (153k)
</a>
or
<a href="papers/padl_tabling.ps.gz">
ps.gz (93k)
</a>
formats.
<p>
For any LP system, tabling can be quite handy in a variety of tasks,
especially if it is efficiently implemented
and fully integrated in the language.
Implementing tabling in Mercury
poses special challenges for several reasons.
First, Mercury is both semantically and culturally quite different from Prolog.
While decreeing that tabled predicates must not include cuts
is acceptable in a Prolog system,
it is not acceptable in Mercury,
since if-then-elses and existential quantification
have sound semantics for stratified programs
and are used very frequently
both by programmers and by the compiler.
The Mercury implementation thus has no option
but to handle interactions of tabling
with Mercury's language features safely.
Second, the Mercury implementation is vastly different from the WAM,
and many of the differences
(e.g. the absence of a trail)
have significant impact on the implementation of tabling.
In this paper, we describe how we adapted the copying approach to tabling
to implement tabling in Mercury.
</p>
</li>

<li>
<strong>
<a name="maclarty-masters">
Practical declarative debugging of Mercury programs.
</a>
</strong>
<br>
Ian MacLarty.
<br>
<em>
Masters thesis,
</em>
Department of Computer Science and Software Engineering,
The University of Melbourne,
July 2005.
<br>
Available in <a href="papers/maclarty-masters.pdf">pdf</a> (1.9M)
or <a href="papers/maclarty-masters.ps.gz">ps.gz</a> (1.2M) formats.
<p>
Debugging is the most unpredictable and potentially expensive phase of the
software development life-cycle. Declarative debuggers ask the user questions
about the correctness of subcomputations in their program. Based on the
user's answers, subcomputations that cannot be the cause of the buggy
behaviour are eliminated. Eventually one subcomputation is left which must be
the cause of the buggy behaviour. Declarative debuggers thus keep track of
which parts of the computation are still suspect, relieving the user of the
burden of having to do so. They also direct the bug search, something that many
users (especially novices) would find difficult to do manually. Even expert
users often find it hard to explore large search spaces systematically, a
limitation that does not apply to software systems. Declarative debuggers thus
have the potential to make the debugging process easier and much more
predictable.
</p>
<p>
Despite these expected benefits, declarative debugging is not yet
widely used in practice to find real bugs. There are three main reasons for
this:
<ol>
<li>Most previous declarative debuggers only support a subset of the
features of their target language that is not sufficient to express real
programs.</li>
<li>Previous declarative debuggers do not scale well when applied to
problems with large search spaces. </li>
<li>Previous declarative debuggers do not do
enough to make the questions easier for the user to answer.</li>
</ol>
</p>
<p>
The declarative
nature of Mercury makes it relatively easy to implement a declarative debugger
that can handle the full language. The version of the Mercury declarative
debugger that was the starting point for this thesis already handled almost all
of Mercury. By extending it to handle exceptions we made it handle the full
language.
</p>
<p>
One problem posed by large search spaces is that they cannot be stored
in memory all at once. This requires only portions of the search space to be
stored in memory at any one time, materializing missing pieces when they are
needed by reexecuting the program. We present the first algorithm for
controlling this rematerialization process that is practical in the presence of
multiple search strategies, minimising reexecutions while keeping memory
consumption within acceptable limits.
</p>
<p>
Another problem with large search spaces
is that previous search strategies either asked far too many questions,
demanded too much in the way of CPU and/or memory resources
or were too inflexible to coexist with other search strategies. For example,
the divide-and-query search strategy is query-optimal in the worst case, however
previous implementations of it often required more memory than is typically
available. We have implemented heuristics which enable divide-and-query to be
used on partially materialized search spaces, making it practical.
</p>
<p>
We also
address the third problem, namely the problem of reducing the complexity of the
debugger's queries. The new declarative debugger allows users to specify
exactly which part of an atom is wrong. The subterm dependency tracking
strategy exploits this extra information to jump directly to the part of the
program that computed the wrong subterm. In many cases, only a few such jumps
are required to arrive at the bug. Subterm dependency tracking can converge on
the bug even more quickly than divide-and-query, and it tends to yield
questions and question sequences that are easier for users to answer.
</p>
<p>
We also
support a variety of other methods of making questions easier to answer. By
trusting some predicates the user can automate answers to all questions about
those predicates (implementing this capability, especially in the presence of
higher order code, is trickier than it seems). We also support a novel
technique that allows custom visualisations of terms to be easily created. If a
call fails a precondition then neither `yes' or `no' is an
appropriate answer to a question from the debugger about the validity of an
answer computed for that call. Our debugger therefore allows users to answer
`inadmissible' to such questions. If all else fails, users can also
skip hard questions.
</p>
<p>
We give evidence that the new declarative debugger can be
used on complex, real world programs by presenting several case studies of real
bugs found in real programs with the aid of the debugger.
</p>
</li>

<li>
<strong>
<a name="ciclops05">
The implementation of minimal model tabling in Mercury (extended abstract).
</a>
</strong>
<br>
Zoltan Somogyi and Konstantinos Sagonas.
<em>
Colloquium on Implementation of Constraint and Logic Programming Systems,
</em>
Barcelona, Spain, October 2005.
<br>
Available in
<a href="papers/ciclops05.pdf">
pdf (312k)
</a>
or
<a href="papers/ciclops05.ps.gz">
ps.gz (90k)
</a>
formats.
<p>
For any LP system, tabling can be quite handy in a variety of tasks,
especially if it is efficiently implemented
and fully integrated in the language.
Implementing tabling in Mercury
poses special challenges for several reasons.
First, Mercury is both semantically and culturally quite different from Prolog.
While decreeing that tabled predicates must not include cuts
is acceptable in a Prolog system,
it is not acceptable in Mercury,
since if-then-elses and existential quantification
have sound semantics for stratified programs
and are used very frequently
both by programmers and by the compiler.
The Mercury implementation thus has no option
but to handle interactions of tabling
with Mercury's language features safely.
Second, the Mercury implementation is vastly different from the WAM,
and many of the differences
(e.g. the absence of a trail)
have significant impact on the implementation of tabling.
In this paper, we describe how we adapted the copying approach to tabling
to implement minimal model tabling in Mercury.
</p>
</li>

<li>
<strong>
<a name="dd3">
Divide-and-query and subterm dependency tracking
in the Mercury declarative debugger.
</a>
</strong>
<br>
Ian MacLarty, Zoltan Somogyi and Mark Brown.
<br>
<em>
Sixth International Symposium on
Automated and Analysis-driven Debugging.
</em>
Monterey, California, September 2005.
<br>
Available in
<a href="papers/dd3.pdf">
pdf (204k)
</a>
or
<a href="papers/dd3.ps.gz">
ps.gz (161k)
</a>
formats.
<p>
We have implemented a declarative debugger for Mercury
that is capable of finding bugs in large, long-running programs.
This debugger implements several search strategies.
We discuss the implementation of two of these strategies
and the conditions under which each strategy is useful.
</p>
<p>
The divide and query strategy
tries to minimize the number of questions asked of the user.
While divide and query can reduce the number of questions
to roughly logarithmic in the size of the computation,
implementing it presents practical difficulties
for computations whose representations do not fit into memory.
We discuss how we get around this problem,
making divide and query practical.
</p>
<p>
Our declarative debugger allows users to specify
exactly which part of an atom is wrong.
The subterm dependency tracking strategy
exploits this extra information to jump directly
to the part of the program that computed the wrong subterm.
In many cases, only a few such jumps are required to arrive at the bug.
Subterm dependency tracking can converge on the bug
even more quickly than divide and query,
and it tends to yield question sequences that are easier for users to answer.
</p>
<p>
&copy; ACM, (2005). This is the author's version of the work. It is
posted here by permission of ACM for your personal use. Not for
redistribution. The definitive version was published in
Proceedings of the Sixth International Symposium on
Automated and Analysis-driven Debugging.
</p>
</li>

<li>
<strong>
<a name="decl_debug">
Annotated event traces for declarative debugging
</a>
</strong>
<br>
Mark Brown and Zoltan Somogyi
<br>
<em>
Unpublished,
</em>
Department of Computer Science and Software Engineering,
The University of Melbourne,
2005.
<br>
Available in
<a href="papers/decl_debug.pdf">
pdf (261k)
</a>
or
<a href="papers/decl_debug.ps.gz">
ps.gz (94k)
</a>
formats.
<p>
Many programmers find debugging a frustrating and unproductive activity.
Declarative debugging
promises to alleviate this problem by automating
some of the reasoning used in the debugging process.
We have implemented a declarative debugger for Mercury.
In the process, we found a problem not addressed
in the existing literature on declarative debuggers,
which considers programs to consist of clauses
(conjunctions of literals):
how to handle if-then-elses.
The problem is that the condition of an if-then-else
should be treated as a negated goal if and only if the condition fails.
Negated contexts may cause a declarative debugger
to switch from wrong answer analysis to missing answer analysis and vice versa.
Since missing answer analysis explores a search space
that is subtly different from the space explored for wrong answer analysis,
the two kinds of analysis need different kinds of trees
to represent the program execution.
For the conditions of if-then-elses,
the debugger does not know which kind of tree to build
until the condition has either succeeded or failed,
by which time it is too late.
To solve this problem,
we have designed a novel data structure, the annotated event trace,
which is flexible enough to support both wrong and missing answer analysis.
The advantages of this data structure are that it is quite compact,
requiring little more space than an ordinary stored event trace,
and that the algorithms to build this data structure
and to derive from it the information required for two kinds of diagnosis
are all simple as well as efficient.
</p>
</li>

<li>
<strong>
<a name="mazur-thesis">
Compile-time garbage collection for the declarative language Mercury.
</a>
</strong>
<br>
Nancy Mazur.
<br>
<em>
Ph.D. thesis,
</em>
Department of Computer Science,
Catholic University of Leuven,
Belgium,
May 2004.
<br>
<a href="papers/CW2004_03_mazur.pdf">
Available here (1.7M).
</a>
<p>
One of the key advantages of modern programming languages
is that they free the programmer from the burden of explicit memory management.
Usually, this means that memory management is delegated to the runtime system
by the use of a run-rime garbage collector (RTGC).
Basically, a RTGC is a dedicated process
that is run in parallel with the user program.
Whenever the user program needs to store some data,
the RTGC provides the desired memory space.
At regular intervals, the RTGC reviews the uses of the allocated memory space,
and recovers those memory cells that have become garbage,
i.e. that cannot be accessed any more by the user program.
</p>
<p>
A complementary form of automatic memory management
is compile-time garbage collection (CGTC),
where the decisions form memory management
are taken at compile time instead of at run-time.
The compiler determines the lifetime of the variables
that are created during the execution of the program,
and thus also the memory that will be associated with these variables.
Whenever the compiler can guarantee that a variable,
or more precisely, parts of the memory resources
that this variable points to at run-time,
will never ever be accessed beyond a certain program instruction,
then the compiler can add instructions to deallocate these resources
at that particular instruction
without compromising the correctness of the code.
If the program instruction is followed by a series of instructions
that require the allocation of new memory cells, then the compiler
can replace the sequence of deallocation and allocation instructions,
by instructions updating the garbage cells, thus reusing these cells.
</p>
<p>
We study the technique of compile-time garbage collection
in the context of Mercury, a pure declarative language.
A key element  of declarative languages is that
they disallow explicit memory updates
(which are common operations in most other programming paradigms)
but they rely instead on term construction and deconstruction
to manipulate the program data.
This places a high demand on the memory management
and makes declarative languages a primary target
for compile-time garbage collection.
Moreover, the clear mathematical foundations of Mercury,
being a pure declarative language,
makes the development of the program analyses
that are necessary for CTGC feasible.
</p>
<p>
In this thesis we define a number of semantics
for the logic programming language Mercury
and formally establish the equivalence between them;
we use these semantics to formalise the different program analysis steps
that are needed to implement a basic CTGC system for Mercury
and prove their safeness.
We extend this basic CGTC system such that it is able to correctly deal
with programs organised into modules and we implement a complete CTGC system
within the Melbourne Mercury Compiler.
To the best of our knowledge,
this is the first and only complete CTGC system
that has ever been built for a programming language.
</p>
</li>

<li>
<strong>
<a name="dmo-thesis">
Precise and expressive mode systems for typed logic programming languages.
</a>
</strong>
<br>
David Overton.
<br>
<em>
Ph.D. thesis,
</em>
Department of Computer Science and Software Engineering,
The University of Melbourne,
December 2003.
<br>
<a href="papers/dmo-thesis.ps.gz">
Available here (602K).
</a>
<p>
In this thesis we look at mode analysis of logic programs.
Being based on the mathematical formalism of predicate logic,
logic programs have no <em>a priori</em> notion of data flow&#8212;a
single logic program may run in multiple <em>modes</em>
where each mode describes, or prescribes, a pattern of data flow.
</p>
<p>
A <em>mode system</em> provides an abstract domain
for describing the flow of data in logic programs,
and an algorithm for analysing programs to <em>infer</em> the
modes of a program or to <em>check</em> the correctness of
<em>mode declarations</em> given by the programmer.
Such an analysis can provide much useful information to the compiler for
optimising the program.
In a prescriptive mode system, mode analysis is also an important part of the
semantic analysis phase of compilation (much like type analysis)
and can inform the programmer of many errors or potential errors in the
program at compile time.
We therefore believe it is an essential component of any industrial strength
logic programming system.
</p>
<p>
Our aim is to develop a strong and prescriptive mode system that is both
as precise and expressive as possible.
We believe this requires a strongly typed and purely declarative
language and so we focus on the language Mercury.
</p>
<p>
The first contribution of our work is to give a detailed description
of Mercury's existing mode system, which is based on abstract interpretation.
Although most of this system has been around for several years,
this is the first time it has been described in this level of detail.
This is also the first time the relationship of the mode system to
the formalism of abstract interpretation has been made clear.
</p>
<p>
Following that, we look at ways of extending the mode system to provide further
precision and expressiveness, and to overcome some of the limitations of the
current system.
</p>
<p>
The first of these extensions is to support a form of constrained parametric
polymorphism for modes.
This is analogous to constrained parametric polymorphic type systems such as
type classes, and adds a somewhat similar degree of expressiveness to the mode
system.
</p>
<p>
Next we look at a method for increasing the precision of the mode analysis by
keeping track of aliases between variables.
The increased precision we gain from this allows an increase in expressiveness
by allowing the use of partially instantiated data structures and more
complex uniqueness annotations on modes.
</p>
<p>
The final area we look at is an alternative approach to mode analysis using
Boolean constraints.
This allows us to design a mode system that can capture complex
mode constraints between variables and
more clearly separates the various tasks required for mode analysis.
We believe that this constraint-based system provides a good platform for
further extension of the Mercury mode system.
</p>
<p>
The work we describe has all been
implemented in the Melbourne Mercury compiler,
although only constrained parametric polymorphism has so far become part of an
official compiler release.
</p>
</li>

<li>
<strong>
<a name = "aadebug03-paper">
Idempotent I/O for safe time travel.
</a>
</strong>
<br>
Zoltan Somogyi.
<em>
Proceedings of the Fifth International Workshop on Automated Debugging,
</em>
Ghent, Belgium, September 2003.
<br>
<a href="papers/aadebug03_paper.pdf">
Available here (143K).
</a>
<p>
Debuggers for logic programming languages have traditionally had
a capability most other debuggers did not:
the ability to jump back to a previous state of the program,
effectively travelling back in time in the history of the computation.
This ``retry'' capability is very useful,
allowing programmers to examine in detail
a part of the computation that they previously stepped over.
Unfortunately, it also creates a problem:
while the debugger may be able to restore the previous values of variables,
it cannot restore the part of the program's state
that is affected by I/O operations.
If the part of the computation being jumped back over performs I/O,
then the program will perform these I/O operations twice,
which will result in unwanted effects ranging
from the benign (e.g. output appearing twice)
to the fatal (e.g. trying to close an already closed file).
</p>
<p>
We present a simple mechanism for ensuring that
every I/O action called for by the program is executed at most once,
even if the programmer asks the debugger to travel back in time
from after the action to before the action.
The overhead of this mechanism is low enough and can be controlled well enough
to make it practical to use it to debug
computations that do significant amounts of I/O.
</p>
</li>

<li>
<strong>
<a name="juliensf-hons">
Termination analysis for Mercury using convex constraints.
</a>
</strong>
<br>
Julien Fischer.
<br>
<em>
Honours report,
</em>
Department of Computer Science and Software Engineering,
The University of Melbourne,
August 2002.
<br>
<a href="papers/juliensf_hons.ps.gz">
Available here (143K).
</a>
<p>
This report presents a new termination analysis for Mercury that
approximates interargument size relationships using convex constraints.
These relationships are derived using an analysis based upon abstract
interpretation.
Although this analysis is more expensive than that of the existing termination
analyser, it is able to prove the termination of a larger class of predicates.
We consider how this analysis interacts with aspects of Mercury such as the
module system, declarative I/O, higher-order code and the foreign language
interface.
</p>
</li>

<li>
<strong>
<a name="conway-thesis">
Towards parallel Mercury.
</a>
</strong>
<br>
Thomas Conway.
<br>
<em>
Ph.D. thesis,
</em>
Department of Computer Science and Software Engineering,
The University of Melbourne,
July 2002.
<br>
<a href="papers/conway-thesis.ps.gz">
Available here (562K).
</a>
<p>
This thesis presents the foundations for extending the implementation
of the declarative logic programming language Mercury
to support the parallel execution of programs.
<p>
The new material in this thesis is in three parts.
The first part
presents an extension to the existing (sequential) execution model for Mercury
that allows programs to be executed in parallel.
Programmers can exploit this extension simply
by replacing some sequential conjunction operators
connecting independent goals with a new parallel conjunction operator.
Such changes do not change the declarative semantics of the program,
but can improve performance.
</p>
<p>
The second part of the new material presents a model
for explicit threading in Mercury,
which is useful when the programmer's goal is not efficiency
but the explicit representation of concurrent tasks
and control of their interactions.
We show how our extended execution model
supports the usual operations on threads.
We also present a new interpretation for Mercury's system for input and output
that provides an intuitive understanding of the interactions
between the I/O operations executed by the different threads of a program
or by different programs.
</p>
<p>
The final part of the new material presented in this thesis
presents a new technique for obtaining
a detailed and accurate picture of the performance of a program.
The basis of our technique is
associating a complete context with each measurement,
rather than approximating the context as conventional profilers do.
In order to make our new profiling system feasible
we have had to develop sophisticated techniques
for reducing the cost of recording complete contexts;
in order to make its output tractable,
we also had to develop techniques for dealing with
interactions between higher order constructs and recursion.
We have also developed a tool for helping programmers
(and eventually compilers) to digest the large volume of data
generated by our profiling technique.
</p>
<p>
All the ideas presented in this thesis have been implemented in
the Melbourne Mercury compiler.
</p>
</li>

<li>
<strong>
<a name="dgj-thesis-final">
Expressive type systems for logic programming languages.
</a>
</strong>
<br>
David Jeffery.
<br>
<em>
Ph.D. thesis,
</em>
Department of Computer Science and Software Engineering,
The University of Melbourne,
February 2002.
<br>
<a href="papers/dgj-thesis-final.ps.gz">
Available here (370K).
</a>
<p>
The aim of this thesis is the design of a type system
for an industrial strength logic programming language.
The type system we describe has been implemented
for the Mercury programming language, in the Melbourne Mercury compiler.
</p>
<p>
We begin by presenting a simple higher order extension
of the Mycroft-O'Keefe type system.
We then use this type system as a basis for two significant extensions.
</p>
<p>
The first extension is the adoption of a type class system similar to that
found in some modern functional languages
in the context of higher order logic programming.
We give a set of typing rules which
both provide a formal definition of type correctness
and define the source-to-source transformation we have used
to implement type classes.
This transformation is simple and effective,
and can be easily shown to preserve Mercury's
mode, determinism and uniqueness correctness properties.
</p>
<p>
The second extension is to allow existentially quantified type variables
in the types of function symbols and of predicates.
This represents the most significant contribution of this thesis.
We then formally define the type system that results from the combination
of both type classes and existential quantification of type variables.
The two type system extensions are quite orthogonal.
As a result, the definition of type correctness in the combined system
is a fairly simple combination of the definitions for the individual systems.
However, the mechanisms contributed by the two systems combine synergistically;
the resulting type system is extremely expressive.
</p>
<p>
We then show how the type system we have designed allows the programmer
to take advantage of many object oriented design techniques.
We give an in depth analysis of object oriented design
and isolate the mechanisms which are likely to result
in reusable and maintainable software systems.
We show that our type system allows the programmer
to directly express these kinds of designs
and discourages the use of the kinds of object oriented designs
which reduce maintainability
by introducing unnecessary implementation dependencies.
</p>
<p>
We show that these principles apply in a direct and simple manner
to the modelling of component interfaces
as supported by modern component frameworks such as CORBA.
We present MCORBA, an implementation of a CORBA binding for Mercury.
This interface is bi-directional,
allowing the programmer to write CORBA components in Mercury
and to use existing CORBA components from within Mercury programs.
</p>
</li>

<li>
<strong>
<a name="p33-overton">
Constraint-based mode analysis of Mercury.
</a>
</strong>
<br>
David Overton, Zoltan Somogyi and Peter Stuckey.
<br>
<em>
Proceedings of the Fourth International Conference on
Principles and Practice of Declarative Programming,
</em>
Pittsburgh, Pennsylvania, October 2002, pages 109-120.
<br>
<a href="papers/p33-overton.ps.gz">
Available here (188K).
</a>
<p>
Recent logic programming languages, such as Mercury and HAL,
require type, mode and determinism
declarations for predicates. This information allows the generation of
efficient target code and the detection of many errors at compile-time.
Unfortunately, mode checking in such languages is difficult. One of the main
reasons is that, for each predicate mode declaration,
the compiler is required to decide
which parts of the procedure bind which variables,
and how conjuncts in the predicate definition should be re-ordered
to enforce this behaviour.
Current mode checking systems limit the possible modes that may be used
because they do not keep track of aliasing information,
and have only a limited ability to infer modes,
since inference does not perform reordering.
In this paper we develop a mode inference system for Mercury
based on mapping each predicate to a system of Boolean constraints
that describe where its variables can be produced.
This allows us to handle programs that are not supported by the existing
system.
</p>
</li>

<li>
<strong>
<a name="p81-somogyi">
Using the heap to eliminate stack accesses.
</a>
</strong>
<br>
Zoltan Somogyi and Peter Stuckey.
<br>
<em>
Proceedings of the Fourth International Conference on
Principles and Practice of Declarative Programming,
</em>
Pittsburgh, Pennsylvania, October 2002, pages 121-132.
<br>
<a href="papers/p81-somogyi.ps.gz">
Available here (190K).
</a>
<p>
The value of a variable is often given by a field of a heap cell,
and frequently the program will pick up the values of several variables
from different fields of the same heap cell.
By keeping some of these variables out of the stack frame,
and accessing them in their original locations on the heap instead,
we can reduce the number of loads from and stores to the stack
at the cost of introducing a smaller number of loads from the heap.
We present an algorithm that finds the optimal set of variables
to access via a heap cell instead of a stack slot,
and transforms the code of the program accordingly.
We have implemented this optimization in the Mercury compiler,
and our measurements show that it can reduce program runtimes by up to 12%
while at the same time reducing program size.
The optimization is straightforward to apply to Mercury
and to other languages with immutable data structures;
its adaptation to languages with destructive assignment
would require the compiler to perform mutability analysis.
</p>
</li>

<li>
<strong>
<a name="high_level_gc">
Accurate garbage collection in an uncooperative environment.
</a>
</strong>
<br>
Fergus Henderson.
<br>
<em>
Proceedings of the 2002 International Symposium on Memory Management,
</em>
Berlin, Germany, June 2002, pages 150-156.
<br>
<a href="papers/high_level_gc.ps.gz">
Available here (83K).
</a>
<p>
Previous attempts at garbage collection in uncooperative environments
have generally used conservative or mostly-conservative approaches.
We describe a technique for doing fully type-accurate
garbage collection in an uncooperative environment,
using a ``shadow stack'' to link structs of pointer-containing variables,
together with the data or code needed to trace them.
We have implemented this in the Mercury compiler, which generates C code,
and present preliminary performance data on the overheads of this technique.
We also show how this technique can be extended to handle multithreaded
applications.
</p>
</li>

<li>
<strong>
<a name="mercury_to_clr">
Compiling Mercury to the .NET Common Language Runtime.
</a>
</strong>
<br>
Tyson Dowd, Fergus Henderson, and Peter Ross.
<br>
<em>
BABEL'01 First International Workshop on
Multi-Language Infrastructure and Interoperability,
</em>
Firenze, Italy, September 2001.  Preliminary Proceedings pages 70-85.
To appear in Electronic Notes in Theoretical Computer Science 59.1.
<br>
<a href="papers/mercury_to_clr.ps.gz">
Available here (93K).
</a>
<p>
The .NET Common Language Runtime (CLR) offers a new opportunity to
experiment with multi-language interoperation, and provides a relatively
rare chance to explore deep interoperation of a wide range of
programming language paradigms.
This article describes how Mercury is compiled to the CLR.
We describe the problems we have
encountered with generating code for the CLR,
give some preliminary benchmark results,
and suggest some possible improvements to the CLR
regarding separate compilation, verifiability, tail calls, and efficiency.
</p>
</li>

<li>
<strong>
<a name="hlc_cc">
Compiling Mercury to high-level C code.
</a>
</strong>
<br>
Fergus Henderson and Zoltan Somogyi.
<br>
<em>
Proceedings of the 2002 International Conference on Compiler Construction
</em>
Grenoble, France, April 2002.
&copy;
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<br>
<a href="papers/hlc_cc.ps.gz">Available here (67K)</a>.
<p>
Many logic programming implementations compile to C,
but they compile to very low-level C, and thus discard many
of the advantages of compiling to a high-level language.
We describe an alternative approach to compiling logic
programs to C, based on continuation passing, that we have used
in a new back-end for the Mercury compiler.
The new approach compiles to much higher-level C code,
which means the compiler back-end and run-time system
can be considerably simpler.
</p>
<p>
We present a formal schema for the transformation,
and give benchmark results which show that this approach delivers
performance that is more than competitive
with the fastest previous implementation,
with greater simplicity and better portability and interoperability.
</p>
<p>
The approach we describe can also be used
for compiling to other target languages,
such as IL (the Microsoft .NET intermediate language).
</p>
<p>
The benchmark data on which the performance evaluation section of this paper
is based is
<a href="papers/hlc_cc_perf.tar.gz">available here (9.7M)</a>.
</p>
</li>

<li>
<strong>
<a name="mu_01_24">
Deep profiling:
engineering a profiler for a declarative programming language.
</a>
</strong>
<br>
Thomas C. Conway and Zoltan Somogyi.
<br>
<em>
Technical Report 2001/24,
</em>
Department of Computer Science, University of Melbourne,
Melbourne, Australia, July 2001, 61 pages.
<br>
<a href="papers/mu_01_24.ps.gz">
Available here (207K).
</a>
<p>
Declarative programs differ from imperative programs in several respects,
the main ones being their heavy use of recursion,
of various forms of polymorphism, and of higher order.
Existing profilers tend not to produce very useful information
in the presence of these constructs.
We present a new profiling technique we call deep profiling
that yields detailed and useful information about programs
even in the presence of these constructs,
information that is significantly richer
than the output of other profilers.
</p>
<p>
The heart of deep profiling is a source-to-source transformation.
We have implemented this transformation and its associated infrastructure
in the compiler for Mercury, a purely declarative logic programming language.
While our measurements of this implementation
show that deep profiling has slightly greater overhead
than some other profiling techniques,
the wealth of information it provides
makes this extra overhead worthwhile.
The deep profiling algorithms themselves
are applicable to most other language styles,
including imperative, object-oriented, and functional languages.
</p>
</li>

<li>
<strong>
<a name="iclp2001_ctgc">
Practical aspects for a working compile time garbage collection system
for Mercury.
</a>
</strong>
<br>
Nancy Mazur, Peter Ross, Gerda Janssens and Maurice Bruynooghe.
<br>
<em>
Proceedings of ICLP 2001 - Seventeenth International Conference on
Logic Programming
</em>,
Paphos, Cyprus, November 2001. Lecture Notes in Computer Science 2237,
Springer Verlag,
Pages 105-119
&copy;
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<br>
<a href="papers/iclp2001_ctgc.ps.gz">
Available here (84K).
</a>
<p>
Compile-time garbage collection (CTGC)
is still a very uncommon feature within
compilers.
In previous work we have developed a compile-time structure
reuse system for Mercury, a logic programming language.
This system
indicates which datastructures can safely be reused at run-time.
As preliminary experiments were promising, we
have continued this work and have now a
working and well performing near-to-ship
CTGC-system built into the Melbourne Mercury
Compiler (MMC).
</p>
<p>
In this paper we present the multiple design decisions leading to this
system, we report the results of using CTGC
for a set of benchmarks, including a
real-world program, and finally we discuss further
possible improvements.
Benchmarks show substantial memory savings and a noticeable reduction
in execution time.
</p>
</li>

<li>
<strong>
<a name="bta_higher_order">
Binding-time analysis by constraint solving:
a modular and higher-order approach for Mercury.
</a>
</strong>
<br>
Wim Vanhoof.
<br>
<em>
Proceedings of the Seventh International Conference on Logic for
Programming and Automated Reasoning
</em>,
Reunion Island, France, November 2000.
Lecture Notes in Computer Science 1955,
Springer Verlag,
Pages 399-416
&copy;
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<br>
<a href="papers/bta_higher_order.ps.gz">Available here (106K)</a>.
<p>
In this paper we present a binding-time analysis for the logic
programming language Mercury. Binding-time analysis is a key analysis
needed to perform off-line program specialisation.  Our analysis deals
with the higher-order aspects of Mercury, and is formulated by means of
constraint normalisation. This allows (at least part of) the analysis to
be performed on a modular basis.
</p>
</li>

<li>
<strong>
<a name="memory_reuse_analysis">
A module based analysis for memory reuse in Mercury.
</a>
</strong>
<br>
Nancy Mazur, Gerda Janssens and Maurice Bruynooghe.
<br>
<em>
Proceedings of the First International Conference on Computational Logic
</em>,
London, United Kingdom, July 2000.
Lecture Notes in Artificial Intelligence,
Springer Verlag,
Pages 1255-1269
&copy;
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<br>
<a href="papers/memory_reuse_analysis.ps.gz">Available here (93K)</a>.
<p>
In previous work Bruynooghe, Janssens and K&aring;gedal developed a
live-structure analysis for Mercury which detects memory cells available
for reuse.  Separate compilation of modules is an essential ingredient
of a language such as Mercury which supports programming in the large.
Hence, to be practical, a live-structure analysis also has to be module
based.  This paper develops a modular live-structure analysis and
extends it with a modular reuse analysis.  It also describes preliminary
results obtained with a first prototype of the module based analysis.
</p>
</li>

<li>
<strong>
<a name="tail_lopstr_lncs">
Making Mercury programs tail recursive.
</a>
</strong>
<br>
Peter Ross, David Overton and Zoltan Somogyi.
<br>
<em>
Proceedings of the Ninth International Workshop on Logic-based Program
Synthesis and Transformation</em>,
Venice, Italy, September 1999.
To appear in Lecture Notes in Computer Science,
Springer Verlag,
&copy;
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<br>
<a href="papers/tail_lopstr_lncs.ps.gz">Available here (84K)</a>.
<p>
We present two optimizations for making Mercury programs tail recursive.
Both operate by taking computations that occur after a recursive call
and moving them before the recursive call, modifying them as necessary.
The first optimization moves calls to associative predicates;
it is a pure source to source transformation.
The second optimization moves construction unifications;
it required extensions to the mode system (to record aliases)
and to the parameter passing convention
(to allow arguments to be returned in memory).
The two optimizations are designed to work together,
and can make a large class of programs tail recursive.
</p>
<p>
The raw data on which the evaluation is based
is available as a <a href="papers/tail_data.tar.gz">5 Kb tar file</a>.
</p>
</li>

<li>
<strong>
<a name="update">
State update transformation.
</a>
</strong>
<br>
Peter Ross and Zoltan Somogyi.
<br>
<em>
</em>
<br>
<a href="papers/update.ps.gz">Available here (57K)</a>.
<p>
Recursive predicates frequently generate some state
which is updated after the recursive call.
We present a source to source transformation
which can move the state update before the recursive call,
thus helping to make the predicate tail recursive,
and report on its implementation in the Mercury compiler.
</p>
</li>

<li>
<strong>
<a name="purity">
Using impurity to create declarative interfaces in Mercury.
</a>
</strong>
<br>
Tyson Dowd, Peter Schachte, Fergus Henderson and Zoltan Somogyi.
<br>
<em>Technical Report 2000/17</em>,
Department of Computer Science, University of Melbourne,
Melbourne, Australia, April 2000, 10 pages.
<br>
<a href="papers/purity.ps.gz">Available here (52K)</a>.
<p>
The logic/functional language Mercury
allows the programmer to annotate predicates and
functions to mark impure predicates, allowing
impure code to be safely integrated into a
declarative language.
</p>
<p>
By using purity declarations with the foreign language
interface, programmers can take advantage of many of the
features of a high level programming language while
writing imperative code to interface with existing
imperative libraries.
</p>
<p>
This paper outlines the purity system in Mercury and
how it affects operational semantics,
compares this purity system with other approaches to declaring
impurity in a pure language,
and gives an extended example of how impurity and foreign language
interfaces can work together to simplify the chore of writing
declarative interfaces to libraries.
</p>
</li>

<li>
<strong>
<a name="liveness">
Towards memory reuse for Mercury.
</a>
</strong>
<br>
Nancy Mazur, Gerda Janssens and Maurice Bruynooghe.
<br>
<em>
Proceedings of the International Workshop on Implementation of
Declarative Languages
</em>,
Paris, France, October 1999
<br>
<a href="papers/liveness.ps.gz">Available here (61K)</a>.
<p>
While Mercury allows destructive input/unique output modes which direct
the compiler to reuse memory, use of these modes can be cumbersome for
the programmer.  In most situations, it would be nicer if the programmer
didn't have to worry about the details of memory management.
<p>
The paper briefly reports on some experiments with a prototype analyser
which aims at detecting memory available for reuse. The prototype is
based on the live-structure analysis developed by us for logic programs
extended with declarations.
</p>
<p>
Yet the major contribution of this paper consists of the development of
the principles of a module based analysis which are essential for the
analysis of large Mercury programs with code distributed over many
modules.
</p>
</li>

<li>
<strong>
<a name="bta">
Binding-time analysis for Mercury.
</a>
</strong>
<br>
Wim Vanhoof and Maurice Bruynooghe.
<br>
<em>
Proceedings of the Sixteenth International Conference on Logic Programming
</em>,
Las Cruces, New Mexico, November 1999, pages 500-514
<br>
<a href="papers/bta.ps.gz">Available here (76K)</a>.
<p>
In this paper, we describe a binding-time analysis (BTA) for a
statically typed and strongly moded pure logic programming language, in
casu Mercury.  Binding-time analysis is the key concept in achieving
off-line program specialisation: the analysis starts from a description
of the program's input available for specialisation, and propagates this
information throughout the program, deriving directives for when and how
to perform specialisation.  Exploiting the possibilities offered by
Mercury's strong type and mode system, we present a completely automatic
BTA dealing with partially static binding-times.
</p>
</li>

<li>
<strong>
<a name="debugger_wlpe99">
The implementation technology of the Mercury debugger.
</a>
</strong>
<br>
Zoltan Somogyi and Fergus Henderson.
<br>
<em>
Proceedings of the Tenth Workshop on Logic Programming Environments
</em>,
Las Cruces, New Mexico, November 1999, pages 35-49.
<br>
<a href="papers/debugger_wlpe99.ps.gz">Available here (66K)</a>.
<p>
Every programming language needs a debugger.
Mercury now has three debuggers:
a simple procedural debugger
similar to the tracing systems of Prolog implementations,
a prototype declarative debugger,
and a debugger based on the idea of automatic trace analysis.
In this paper, we present the shared infrastructure
that underlies the three debuggers,
and describe the implementation of the procedural debugger.
We give our reasons for each of our main design decisions,
and show how several of these decisions are rooted in our experience
with the debugging of large programs working with large data structures.
</p>
</li>

<li>
<strong>
<a name="tail_lopstr">
Making Mercury programs tail recursive (extended abstract).
</a>
</strong>
<br>
Peter Ross, David Overton and Zoltan Somogyi.
<br>
<em>
Pre-Proceedings of the Ninth International Workshop on Logic-based Program
Synthesis and Transformation
</em>,
Venice, Italy, September 1999, pages 107-118.
<br>
<a href="papers/tail_lopstr.ps.gz">Available here (62K)</a>.
<p>
This paper has been superceded by the LNCS version.
</p>
</li>

<li>
<strong>
<a name="rtti_ppdp">
Run time type information in Mercury.
</a>
</strong>
<br>
Tyson Dowd, Zoltan Somogyi, Fergus Henderson, Thomas Conway and David Jeffery.
<br>
<em>
Proceedings of the International Conference
on the Principles and Practice of Declarative Programming
</em>,
Paris, France, September/October 1999,
Lecture Notes in Computer Science 1702,
Springer Verlag,
Pages 224-243,
&copy;
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<br>
<a href="papers/rtti_ppdp.ps.gz">Available here (75K)</a>.
<p>
The logic/functional language Mercury
uses a strong, mostly static type system
based on polymorphic many-sorted logic.
For efficiency,
the Mercury compiler uses type specific representations of terms,
and implements polymorphic operations such as unifications
via generic code invoked with descriptions of the actual types of the operands.
These descriptions, which consist of automatically generated data and code,
are the main components of the Mercury runtime type information (RTTI) system.
We have used this system to implement several extensions of the Mercury system,
including an escape mechanism from static type checking,
generic input and output facilities, a debugger, and automatic memoization,
and we are in the process of using it
for an accurate, native garbage collector.
We give detailed information
on the implementation and uses of the Mercury RTTI system
as well as measurements of the space costs of the system.
</p>
<p>
The raw data on which the evaluation is based
is available as a <a href="papers/rtti_data.tar.gz">70 Kb tar file</a>
</p>
</li>

<li>
<strong>
<a name="stayl_hons">
Optimization of Mercury programs.
</a>
</strong>
<br>
Simon Taylor.
<br>
<em>
Honours report.
</em>
Department of Computer Science, University of Melbourne, November 1998.
<br>
<a href="papers/stayl_hons.ps.gz">
Available here (120K).
</a>
<p>
This paper describes the implementation of several of the high-level
optimization passes of the Mercury compiler, including deforestation,
type specialization, constraint propagation and structure reuse.
</p>
</li>

<li>
<strong>
<a name="mcorba_padl99">
MCORBA: A CORBA Binding for Mercury.
</a>
</strong>
<br>
David Jeffery, Tyson Dowd and Zoltan Somogyi.
<br>
In <em>
Proceedings of the First International Workshop
on Practical Aspects of Declarative Languages
</em>,
San Antonio, Texas,
January 1999,
Lecture Notes in Computer Science 1551,
Springer Verlag,
Pages 211-227,
&copy;
<a href="http://www.springer.de/comp/lncs/index.html">Springer-Verlag</a>.
<br>
<a href="papers/mcorba_padl99.ps.gz">Available here (65K)</a>.
<p>
MCORBA is a binding to the CORBA distributed object framework
for the purely declarative logic/functional language Mercury.
The binding preserves the referential transparency of the language,
and has several advantages
over similar bindings for other strongly typed declarative languages.
As far as we know, it is the first such binding to be bidirectional;
it allows a Mercury program both to operate upon CORBA components
and to provide services to other CORBA components.
Whereas the Haskell binding for COM
maps COM interfaces onto Haskell types,
MCORBA maps CORBA interfaces onto Mercury type classes.
Our approach simplifies the mapping,
makes the implementation of CORBA's interface inheritance straightforward,
and makes it trivial for programmers to provide
several different implementations of the same interface.
It uses existential types to model the operation
of asking CORBA for an object that satisfies a given interface
but whose representation is unknown.
</p>
</li>

<li>
<strong>
<a name="mu_98_13">
Type classes in Mercury.
</a>
</strong>
<br>
David Jeffery, Fergus Henderson and Zoltan Somogyi.
<br>
<em>
Technical Report 98/13,
</em>
Department of Computer Science, University of Melbourne,
Melbourne, Australia, September 1998, 22 pages.
<br>
<a href="papers/mu_98_13.ps.gz">
Available here (82K).
</a>
<p>
In this paper, we explain how we have extended Mercury's type system
to include support for type classes.
We give a formal semantics for this extension to our type system,
adapting the typing rules used in functional languages
to the differing demands of logic programming languages.
We show that type classes integrate very nicely
with Mercury's mode, uniqueness and determinism systems,
and describe how our implementation works.
</p>
</li>

<li>
<strong>
<a name="sas97">
Termination analysis for Mercury.
</a>
</strong>
<br>
Chris Speirs, Zoltan Somogyi and Harald Sondergaard.
<br>
<em>
Proceedings of the Fourth Static Analysis Symposium
</em>,
Paris, France, September 1997, pages 157-171.
<a href="papers/sas97.ps.gz">available here (75K)</a>.
A longer version of the paper appeared as
Technical Report 97/9,
Department of Computer Science, University of Melbourne,
Melbourne, Australia, July 1997, 25 pages.
it is <a href="papers/mu_97_09.ps.gz">available here (99K)</a>.
<p>
This paper presents the algorithms of the Mercury termination analyser,
discusses how real-world aspects of the language
such as modules, higher-order features, foreign language code,
and declarative input/output can be handled,
and evaluates the performance of the analyser
both on a set of standard test programs and on the Mercury compiler itself.
</p>
<p>
The raw data on which the evaluation is based is available
as a <a href="papers/termination_data.tar.gz">5.2 Mb tar file</a>.
</p>
</li>

<li>
<strong>
<a name="jicslpw">
Status of the Mercury system.
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson, Thomas Conway, Andrew Bromage,
Tyson Dowd, David Jeffery, Peter Ross, Peter Schachte and Simon Taylor.
<br>
<em>
Proceedings of the JICSLP '96 Workshop on Parallelism and
Implementation Technology for (Constraint) Logic Programming Languages,
</em>
Bonn, Germany, September 1996, pages 207-218.
<br>
<a href="papers/jicslpw.ps.gz">Available here (46K)</a>.
<p>
</li>

<li>
<strong>
<a name="jlp">
The execution algorithm of Mercury:
an efficient purely declarative logic programming language.
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
<br>
<em>
Journal of Logic Programming,
</em>
volume 29, number 1-3, October-December 1996, pages 17-64.
<br>
<a href="papers/jlp.ps.gz">Available here (138K)</a>.
<br>
Elsevier owns the copyright of this paper;
it is made available here by their permission.
<p>
This paper contains a brief overview of the Mercury language, and a
reasonably detailed overview of the implementation technology used in
the Mercury compiler.  It describes the abstract machine that the
compiler generates code for.  (Our other papers listed below go
into more detail on exactly how the code is generated, and on how
the abstract machine instructions are implemented as C or GNU C code.)
</p>
<p>
The raw data on which the evaluation is based
is available on our <a href="./benchmarks.html">benchmarking page</a>.
</p>
</li>

<li>
<strong>
<a name="acsc96">
Determinism analysis in the Mercury compiler.
</a>
</strong>
<br>
Fergus Henderson, Zoltan Somogyi and Thomas Conway.
<br>
<em>
Proceedings of the Australian Computer Science Conference,
</em>
Melbourne, Australia, January 1996, pages 337-346.
<br>
<a href="papers/acsc96.ps.gz">Available here (78K)</a>.
A longer version of the paper is
<a href="papers/detism.ps.gz">available here (76K)</a>.
<p>
This paper discusses Mercury's determinism system in detail, including
the algorithms for switch detection, deep indexing, determinism
inference, and determinism checking.
</p>
</li>

<li>
<strong>
<a name="code_gen_mit">
Code generation for Mercury.
</a>
</strong>
<br>
Thomas Conway, Fergus Henderson, and Zoltan Somogyi.
<br>
<em>
Proceedings of the 1995 International Symposium on Logic Programming,
</em>
Portland, Oregon, December 1995, pages 242-256.
<br>
<a href="papers/code_gen_mit.ps.gz">Available here (68K)</a>.
<p>
This paper describes the structure of the Mercury compiler,
its calling conventions,
and the algorithms it uses in generating code.
These algorithms include lazy code generation
and a novel way of handling nested disjunctions.
</p>
</li>

<li>
<strong>
<a name="mercury_to_c">
Compiling logic programs to C
using GNU C as a portable assembler.
</a>
</strong>
<br>
Fergus Henderson, Zoltan Somogyi and Thomas Conway.
<br>
<em>
Proceedings of the ILPS '95 Postconference Workshop on
Sequential Implementation Technologies for Logic Programming Languages.
</em>
Portland, Oregon, December 1995.
<br>
<a href="papers/mercury_to_c.ps.gz">Available here (65K)</a>.
<p>
This paper discusses the merits of using C, and in particular GNU C,
as an intermediate target language for the compilation of logic programs,
and describes the approach we have taken in the implementation of Mercury.
</p>
</li>

<li>
<strong>
<a name="acsc95">
Mercury: an efficient purely declarative logic programming language.
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
<br>
<em>
Proceedings of the Australian Computer Science Conference,
</em>
Glenelg, Australia, February 1995, pages 499-512.
<br>
<a href="papers/acsc95.ps.gz">Available here (85K)</a>.
<p>
An overview paper.
</p>
</li>

<li>
<strong>
<a name="ilps94w">
The implementation of Mercury:
an efficient purely declarative logic programming language.
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
<br>
<em>
Proceedings of the ILPS '94 Postconference Workshop on
Implementation Techniques for Logic Programming Languages,
</em>
Syracuse, New York, November 1994.
<br>
<a href="papers/ilps94w.ps.gz">Available here (96K)</a>.
<p>
The first paper on Mercury. It is superseded by the paper
in the Journal of Logic Programming.
</p>
</li>

<li>
<strong>
<a name="conway_hons">
Code generation for Mercury.
</a>
</strong>
<br>
Thomas Conway.
<br>
<em>
Honours report.
</em>
Department of Computer Science, University of Melbourne, November 1994.
<br>
<a href="papers/conway_hons.ps.gz">Available here (188K)</a>.
<p>
This is the first paper on the code generator.
Warning: several aspects of the code generator have changed
since this paper was written.
Some of these are documented in the version in the ILPS 95 proceedings.
</p>
</li>
</ul>

<hr>

<h2><a name="related">Related Papers</a></h2>

<p>
<a name="mc_swese_2007">
This paper covers a case study where Mercury was used as an implementation
language.
</a>
</p>

<ul class="nonindentlist">
<li>
<strong>
Ontology driven software engineering for real life applications.
</strong>
<br>
Michel Vanden Bossche, Peter Ross, Ian MacLarty, Bert Van Nuffelen,
Nikolay Pelov.
<br>
<em>
3rd International Workshop on Semantic Web Enabled
Software Engineering (SWESE 2007)
</em>
Innsbruck, Austria, 2007.
<br>
<a href="papers/mc_swese_2007.pdf">
Available here (121K).
</a>
<p>
In this paper we introduce ODASE (Ontology Driven Architecture for Software
Engineering). We present how we used ODASE to build a 250 person month
e-insurance project for a multi-national insurance firm, where only 35% of the
requirements were known at kick- off.  We required one third of the time of the
next closest quote for the project, and a similar project built classically at
another insurance firm required also around three times the resources.
[The ODASE platform uses Mercury as its implementation language.]
</p>
</li>
</ul>

<p>
<a name="mu_97_23">
This paper gives an introduction to automatic termination analysis.
It surveys termination analysis of logic programs and provides an
overview of the important concepts involved in automatic termination
analysis.
</a>
</p>

<ul class="nonindentlist">
<li>
<strong>
Termination analysis for logic programs.
</strong>
<br>
Chris Speirs.
<br>
<em>
Technical Report 97/23,
</em>
Department of Computer Science, University of Melbourne, October 1997.
<br>
<a href="papers/mu_97_23.ps.gz">
Available here (67K).
</a>
</li>

</ul>

<p>
<a name="vision">
This paper outlines the features that we believe to be important
in a modern logic programming language:
</a>
</p>

<ul class="nonindentlist">
<li>
<strong>
Logic programming for the real world
</strong>
<br>
Zoltan Somogyi, Fergus Henderson, Thomas Conway and Richard O'Keefe.
<br>
<em>
Proceedings of the ILPS '95 Postconference Workshop on
Visions for the Future of Logic Programming,
</em>
Portland, Oregon, December 1995.
<br>
<a href="papers/vision.ps.gz">
Available here (59K).
</a>
<p>
</li>

</ul>
<p>
The mode system and the uniqueness system of Mercury
are based on the following papers:
<p>

<ul class="nonindentlist">

<li>
<strong>
<a name="iclp87">
A system of precise modes for logic programs.
</a>
</strong>
<br>
Zoltan Somogyi.
<br>
<em>
Proceedings of the Fourth International Conference on Logic Programming,
</em>
Melbourne, Australia, May 1987, pages 769-787.
<br>
<a href="papers/iclp87.ps.gz">
Available here (40K).
</a>
<p>
</li>

<li>
<strong>
<a name="zs_phd_thesis">
A parallel logic programming system based on strong and precise modes.
</a>
</strong>
<br>
Zoltan Somogyi.
<br>
<em>
Ph.D. Thesis.
</em>
Department of Computer Science,
The University of Melbourne.
January 1989, 148 pages.
<br>
<a href="papers/zs_thesis.ps.gz">
Available here (348K).
</a>
<p>
</li>

<li>
<strong>
<a name="fjh_hons_thesis">
Strong modes can change the world!
</a>
</strong>
<br>
Fergus Henderson.
<br>
<em>
Honours Report.
</em>
Department of Computer Science, University of Melbourne, November 1993.
<br>
<a href="papers/fjh_hons.ps.gz">Available here (114K).
</a>
<p>
</li>

</ul>
<p>
<a name="mu_96_45">
The following paper describes the method used to express database
transactions and updates that is used in the Mercury ODBC database
interface.
</a>
</p>
<p>
The same kind of approach was also once used in the Mercury interface to the
Aditi deductive database system, although both of these no longer exist.

</p>
<ul class="nonindentlist">

<li>
<strong>
Database transactions in a purely declarative logic programming language.
</strong>
<br>
David B. Kemp, Thomas Conway, Evan Harris, Fergus Henderson,
Kotagiri Ramamohanarao and Zoltan Somogyi.
<br>
<em>
Technical Report 96/45
</em>
Department of Computer Science, University of Melbourne, December 1996.
<br>
<a href="papers/tr_96_45.ps.gz">
Available here (58K)
</a>
<a href="papers/tr_96_45_cover.ps.gz">
with cover page.
</a>
</li>
</ul>

<p>
<a name="tr90-2">
The following paper was also relevant to the Aditi interface mentioned above.
It describes a source-to-source transformation that was once implemented in the
Mercury compiler.
</a>

</p>
<ul class="nonindentlist">

<li>
<strong>
Right-, left-, and multi-linear rule transformations that maintain
context information.
</strong>
<br>
David B. Kemp and Kotagiri Ramamohanarao and Zoltan Somogyi.
<br>
<em>
Technical Report 90/2
</em>
Department of Computer Science, University of Melbourne, October 1997.
<br>
<a href="papers/tr90-2.ps.gz">
Available here (48K).
</a>
Note that this paper incorrectly claims that
the context transformation can be applied to
mixed-linear predicates containing pseudo-left-linear rules
as well as other linear rules.
It is corrected in David Kemp's thesis.
</li>

</ul>

<hr>

<h2><a name="presentations">Presentations on Mercury</a></h2>

<ul class="nonindentlist">

<li>
<strong>
<a name="subword_talk">
Packing sub-word-size arguments.
</a>
</strong>
<br>
Zoltan Somogyi.
<br>
<em>
YesLogic,
</em>
Melbourne, Australia, October 2018.
<br>
<a href="papers/subword_talk_2018_10_12.pdf">
Available here (264K).</a>
<p>
</li>

<li>
<strong>
<a name="mfug_talk">
The Mercury programming language.
</a>
</strong>
<br>
Paul Bone, based on slides by Zoltan Somogyi.
<br>
<em>
<a href="http://www.meetup.com/Melbourne-Functional-User-Group-MFUG/">
Melbourne Functional User Group
</a>
</em>
Melbourne, Australia, April 2015.
<br>
<a href="papers/mfug_talk.pdf">
Available here (115K)
</a>
The talk was performed as in two halves.
The second half of the talk used slides from Paul's
<a href="papers.html#pbone_completion">Ph.D. completion seminar</a>.
<p>
</li>

<li>
<strong>
<a name="pbone_completion">
Automatic parallelism for Mercury.
</a>
</strong>
<br/>
Paul Bone.
<em>
Ph.D. Completion Seminar
</em>
Department of Computing and Information Systems,
The University of Melbourne.
May 2012
<a href="papers/pbone_completion.pdf">
Available here (422K)
</a>
The corresponding thesis is available
<a href="papers.html#pbone_phd_thesis">here</a>.
<p>
</li>

<li>
<strong>
<a name="loop_control_talk">
Controlling loops in parallel Mercury code.
</a>
</strong>
<br/>
Paul Bone, Zoltan Somogyi and Peter Schachte.
<em>
Declarative Aspects and Applications of Multicore Programming
</em>
Philadelphia, Pennsylvania, USA, January 2012.
<a href="papers/loop_control_talk.pdf">
Available here (168K)
</a>
The corresponding paper is available
<a href="papers.html#loop_control">here</a>.
<p>
</li>

<li>
<strong>
<a name="threadscope_talk">
Profiling parallel Mercury programs with ThreadScope.
</a>
</strong>
<br/>
Paul Bone and Zoltan Somogyi.
<em>
21st Workshop on Logic-based methods in Programming Environments.
</em>
Lexington, Kentucky, July 2011.
<a href="papers/threadscope_talk.pdf">
Available here (338K)
</a>
<a href="papers.html#threadscope">corresponding paper</a>
<p>
</li>

<li>
<strong>
<a name="overlap_talk">
Estimating the overlap between dependent computations
for automatic parallelization.
</a>
</strong>
<br/>
Paul Bone, Zoltan Somogyi and Peter Schachte.
<em>
27th International Conference on Logic Programming (ICLP'11)
</em>
Lexington, Kentucky, July 2011.
<a href="papers/dep_par_conj_overlap_talk.pdf">
Available here (272K)
</a>
<a href="papers.html#overlap">corresponding paper</a>
<p>
</li>

<li>
<strong>
<a name="dep_and_parallel_talk">
Minimizing the overheads of dependent AND-parallelism.
</a>
</strong>
<br/>
Peter Wang and Zoltan Somogyi.
<em>
27th International Conference on Logic Programming (ICLP'11)
</em>
Lexington, Kentucky, July 2011.
<a href="papers/minimizing_overheads_talk.pdf">
Available here (106K)
</a>
<a href="papers.html#dep_and_parallel">corresponding paper</a>
<p>
</li>

<li>
<strong>
<a name="luv_2011">
The Mercury project.
</a>
</strong>
<br/>
Zoltan Somogyi.
<em>
A presentation for the <a href="http://luv.asn.au">Linux Users of Victoria</a>
</em>
Melbourne Australia.
June 2011
<a href="papers/luv_2011.pdf">
Available here (228K)
</a>
<p>
</li>

<li>
<strong>
<a name="google_2010_autopar">
Automatic parallelisation for Mercury.
</a>
</strong>
<br/>
Paul Bone.
<em>
A Tech Talk at Google Sydney and a seminar at The University of New South Wales
</em>
Sydney Australia,
December 2010
<a href="papers/google_2010_autopar.pdf">
Available here (1.1M).
</a>
<p>
</li>

<li>
<strong>
<a name="linuxconf_2010_autopar">
Automatic parallelisation in Mercury.
</a>
</strong>
<br/>
Paul Bone.
<em>
Multicore Mini conference, Linuxconf Australia,
</em>
Wellington NZ, 
January 2010.
<a href="papers/linuxconf_2010_autopar.pdf">
Available here (542K).
</a>
<p>
</li>

<li>
<strong>
<a name = "leuven09">
Towards automatic parallelization of Mercury programs.
</a>
</strong>
<br>
Zoltan Somogyi.
<em>
Catholic University of Leuven,
Belgium,
</em>
17 November 2009.
<a href="papers/leuven_nov09_talk.pdf">
Available here (168K).
</a>
<p>
</li>

<li>
<strong>
<a name = "fpu_rules_2009">
Writing business rules engines in Mercury.
</a>
</strong>
<br>
Ian MacLarty.
<em>
Functional Programming Union, University of Melbourne,
</em>
24 July 2009.
<a href="papers/fpu_rules_2009.pdf">
Available here (156K).
</a>
<p>
</li>

<li>
<strong>
<a href="papers.html#packrat-padl08">
DCGs + memoing = packrat parsing; but is it worth it?
</a>
</strong>
<br>
Ralph Becket and Zoltan Somogyi,
<em>
Proceedings of the Tenth International Symposium
on Practical Aspects of Declarative languages,
</em>
San Francisco, California, January 2008.
<a href="papers/packrat_talk.pdf">
Available here (140K).</a>
<p>
</li>

<li>
<strong>
<a name = "mc_owl_mercury_talk_14_08_2007">
Ontology driven software development with Mercury.
</a>
</strong>
<br>
Ian MacLarty, Peter Ross.
<em>
University of Melbourne.
</em>
14 August 2007.
<a href="papers/mc_owl_mercury_talk_14_08_2007.pdf">
Available here (370K).
</a>
<p>
</li>

<li>
<strong>
<a name = "g12_unclean">
Unclean! Unclean! or purity issues in declarative constraint logic programming.
</a>
</strong>
<br>
Ralph Becket.
<em>
University of Melbourne.
</em>
28 March 2006.
<a href="papers/g12_unclean.pdf.gz">
Available here (131K).
</a>
<p>
</li>

<li>
<strong>
<a name = "aadebug05-talk">
Divide-and-query and subterm dependency tracking
in the Mercury declarative debugger.
</a>
</strong>
<br>
Ian MacLarty, Zoltan Somogyi and Mark Brown.
<em>
Talk presented at the Sixth International
Symposium on Automated and Analysis Driven Debugging,
</em>
Monterey, USA, September 2005.
<a href="papers/aadebug05_talk.pdf">
Available here (95K).
</a>
<p>
</li>

<li>
<strong>
<a name = "aadebug03-talk">
Idempotent I/O for safe time travel.
</a>
</strong>
<br>
Zoltan Somogyi.
<em>
Invited talk presented at
the Fifth International Workshop on Automated Debugging,
</em>
Ghent, Belgium, September 2003.
<a href="papers/aadebug03_talk.pdf">
Available here (20K).
</a>
<p>
</li>

<li>
<strong>
<a name = "ppdp02mode-talk">
Constraint-based mode analysis of Mercury.
</a>
</strong>
<br>
David Overton, Zoltan Somogyi and Peter J. Stuckey.
<em>
Talk presented at Fourth International Conference
on Principles and Practice of Declarative Programming.
</em>
Pittsburgh, Pennsylvania, October 2002.
<a href="papers/ppdp02_mode.pdf">
Available here (117K).
</a>
<p>
</li>

<li>
<strong>
<a name = "ppdp02stack-talk">
Using the heap to eliminate stack accesses.
</a>
</strong>
<br>
Zoltan Somogyi and Peter J. Stuckey.
<em>
Talk presented at Fourth International Conference
on Principles and Practice of Declarative Programming.
</em>
Pittsburgh, Pennsylvania, October 2002.
<a href="papers/ppdp02_stack.ps">
Available here (26K).
</a>
<p>
</li>

<li>
<strong>
<a name="sas_talk">
Termination analysis for Mercury.
</a>
</strong>
<br>
Chris Speirs, Zoltan Somogyi and Harald Sondergaard.
<br>
<em>
Talk presented at the Fourth Static Analysis Symposium.
</em>
Paris, France, September 1997.
<a href="papers/sas_talk.ps.gz">
Available here (6K).
</a>
<p>
</li>

<li>
<strong>
<a name="unif">
Unification in Mercury.
</a>
</strong>
<br>
Zoltan Somogyi.
<br>
<em>
Invited talk presented at the Eighth Benelux Workshop on Logic Programming.
</em>
Louvain-la-Neuve, Belgium, September 1996.
<a href="papers/unif.ps.gz">
Available here (12K).
</a>
<p>
</li>

<li>
<strong>
<a name="jicslp_talk">
The design and implementation of Mercury.
</a>
</strong>
<br>
Zoltan Somogyi and Fergus Henderson.
<br>
<em>
Tutorial presented at the Joint International
Conference and Symposium on Logic Programming.
</em>
Bonn, Germany, September 1996.
<a href="papers/jicslp_talk.ps.gz">
Available here (18K).
</a>
<p>
</li>

<li>
<strong>
<a name="jicslpw_talk">
Status of the Mercury system.
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson, Thomas Conway, Andrew Bromage,
Tyson Dowd, David Jeffery, Peter Ross, Peter Schachte and Simon Taylor.
<br>
<em>
Presented at the JICSLP '96 Workshop on Parallelism and
Implementation Technology for (Constraint) Logic Programming Languages,
</em>
Bonn, Germany, September 1996.
<a href="papers/jicslpw_talk.ps.gz">
Available here (5K).
</a>
<p>
</li>

<li>
<strong>
<a name="acsc95_slides">
Mercury:
an efficient purely declarative logic programming language.
</a>
</strong>
<br>
Zoltan Somogyi, Fergus Henderson and Thomas Conway.
<br>
<em>
Presented at the Eighteenth Australasian Computer Science Conference,
</em>
Adelaide, South Australia, February 1995.
<a href="papers/acsc95_slides.ps.gz">
Available here (33K).
</a>
<p>
</li>

<li>
<strong>
<a name="257_1999">
Lecture notes for the expanded Mercury segment of the subject
433-257 Frontiers of Computer Science, given in 1999
(whereas the segment in 1997 had four lectures, in 1999 it had six).
</a>
</strong>
<br>
Zoltan Somogyi.
<br>
<a href="papers/257_1999.ps.gz">
Available here (40K).
</a>
<p>
</li>

<li>
<strong>
<a name="257">
Lecture notes for the Mercury segment of the subject
433-257 Frontiers of Computer Science, given in 1997.
</a>
</strong>
<br>
Zoltan Somogyi.
<br>
<a href="papers/257.ps.gz">
Available here (21K).
</a>
<p>
</li>

<li>
<strong>
<a name="247">
Lecture notes for the Mercury segment of the subject
433-247 Frontiers of Computer Science, given in 1995.
</a>
</strong>
<br>
Zoltan Somogyi.
<br>
<a href="papers/247.ps.gz">
Available here (21K).
</a>
<p>
</li>

<li>
<strong>
<a name="dgj-talk">
Type classes for logic programming languages, given in March 1998.
</a>
</strong>
<br>
David Jeffery.
<br>
<a href="papers/dgj-talk.ps.gz">
Available here (30K).
</a>
<p>
</li>

<li>
<strong>
<a name="rtti_talk_98">
Runtime type information in Mercury, given in March 1998.
</a>
</strong>
<br>
Tyson Dowd.
<br>
<a href="papers/rtti_talk_98.ps.gz">
Available here (48K).
</a>
<p>
</li>
</ul>

<hr>
<p>
All these papers and presentations are for A4 paper.
Unfortunately, we cannot generate US paper size versions.
</p>
